// Require the necessary discord.js classes
//Client, Events, GatewayIntentBits, Partials
const {GuildScheduledEventEntityMetadataOptions, GuildScheduledEventEntityType, GuildScheduledEventPrivacyLevel,  GuildScheduledEventManager, AttachmentBuilder, Client, Events, GatewayIntentBits, Partials, EmbedBuilder, IntegrationApplication, Embed} = require('discord.js');
const {parentTempChannels, canalEventos, inviteServer, sugDeneg, sugerenciasImpl, logsTicket, canalSugerencias , idGoogleSheets, logComandos, canalBienvenida, MensajeStatus, token, CLIENT_ID, numMesas, adminsIDS, emojiAperturaTicket, guildID, categoriaTicketsID, idRoleSoporte, canalLogsMd, numeroMáximoReservasUser, diasAntelacionReserva} = require('./config.json');
const fs = require('fs');
const os = require('os');
const CPU = require('os-utils');
// Create a new client instance
//: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMessageReactions],
//GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMessageReactions
const client = new Client({ intents: [GatewayIntentBits.GuildPresences, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMessageReactions, GatewayIntentBits.DirectMessages, GatewayIntentBits.DirectMessageReactions], partials: [ Partials.Message, Partials.Channel, Partials.Reaction, Partials.User, Partials.GuildScheduledEvent]});

// When the client is ready, run this code (only once).
// The distinction between `client: Client<boolean>` and `readyClient: Client<true>` is important for TypeScript developers.
// It makes some properties non-nullable.

//La fecha del date es en formato americano

/*
  Cargamos bases de datos necesarias.
*/
const dbReservas = JSON.parse(fs.readFileSync("./databases/reservas.json", "utf8"));
const dbReservasEscribir = require("./databases/reservas.json");
const dbReactionRole = JSON.parse(fs.readFileSync("./databases/reactionrole.json"));
const dbReactionRoleEscribir = require("./databases/reactionrole.json");
const dbUseraServer = JSON.parse(fs.readFileSync("./databases/useraserver.json"));
const dbUseraServerEscribir = require("./databases/useraserver.json");
const dbServeraUser = JSON.parse(fs.readFileSync("./databases/serverauser.json"));
const dbServeraUserEscribir = require("./databases/serverauser.json");
const bloqueadosModmail = JSON.parse(fs.readFileSync("./databases/bloqueadosmodmail.json"));
const bloqueadosModmailEscribir = require("./databases/bloqueadosmodmail.json");
const dbReservasHechasPorUser = JSON.parse(fs.readFileSync("./databases/reservashechasporuser.json"));
const dbReservasHechasPorUserEscribir = require("./databases/reservashechasporuser.json");
const dbSugerencias = JSON.parse(fs.readFileSync("./databases/sugerencias.json"));
const dbSugerenciasEscribir = require("./databases/sugerencias.json");
const dbTempchanels = JSON.parse(fs.readFileSync("./databases/tempchannels.json"));
const dbTempchanelsEscribir = require("./databases/tempchannels.json");
const dbTorneosParticipando = JSON.parse(fs.readFileSync("./databases/torneosparticipando.json"));
const dbTorneosParticipandoEscribir = require("./databases/torneosparticipando.json"); /* Guardamos el torneo y un array con las ids participantes */
/* API de google para los sheets: */
//bot-discordjs-sheets-407312-308c06575d72.json
const { GoogleSpreadsheet } = require('google-spreadsheet');
const { JWT } = require('google-auth-library');
var creds = require('./credenciales_google/bot-discordjs-sheets-407312-308c06575d72.json');
// Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
const serviceAccountAuth = new JWT({
  // env var values here are copied from service account credentials generated by google
  // see "Authentication" section in docs for more info
  email: creds.client_email,
  key: creds.private_key,
  scopes: [
    'https://www.googleapis.com/auth/spreadsheets',
  ],
});

/*-------------------------------------------------- */
//Verificación para borrar de la database reservas de dias anteriores. (Esto se ejecutará cada 15 minutos por ejemplo).

setInterval(()=>{
  for (var clave in dbReservasEscribir) {
    if (dbReservasEscribir.hasOwnProperty(clave)) {
      // Accede al valor correspondiente utilizando la clave
      var arrFecha = pasarAFecha(clave);
      var fechaHoy = new Date();
      var DateReserva = new Date(arrFecha[1]+"/"+(arrFecha[0])+ "/"+fechaHoy.getFullYear());
      //console.log(fechaHoy);
      //console.log('===================')
     //console.log(DateReserva);
      if((fechaHoy.getDay()  == DateReserva.getDay()) && (fechaHoy.getMonth() == DateReserva.getMonth() ) && (fechaHoy.getFullYear() == DateReserva.getFullYear())){
        /* Significa que la fecha de la reserva es el dia de hoy.
           Ahora debemos verificar que haya pasado la hora de inicio.
        */
        dbReservasEscribir[clave].arrayHoraInicio.forEach(async horasInicio =>{
          if(fechaHoy.getHours() >= parseInt(horasInicio)){
            /* Ya ha pasado la hora de la reserva */
            let pos = dbReservasEscribir[clave].arrayHoraInicio.indexOf(horasInicio);
            var userID = dbReservasEscribir[clave].arrayUserID[pos];
            if(dbReservasEscribir[clave].longitud != 1){
              /* Debemos preservar las fechas existentes posteriores. */
              dbReservasEscribir[clave].arrayHoraInicio = eliminarDelArray(dbReservasEscribir[clave].arrayHoraInicio, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].arrayHoraFin = eliminarDelArray(dbReservasEscribir[clave].arrayHoraFin, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].arrayMesas = eliminarDelArray(dbReservasEscribir[clave].arrayMesas, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].arrayUserID = eliminarDelArray(dbReservasEscribir[clave].arrayUserID, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].longitud = dbReservasEscribir[clave].longitud -1;
            } else {
              /*Nos cargamos los datos del día de hoy. */
              delete dbReservasEscribir[clave];
            }
            await escribirDatos(1);
            /*En cualquiera de los casos tenemos que liberar la reserva hecha por el user en sus datos */
            if(dbReservasHechasPorUserEscribir[userID].numReservas != 1){
              dbReservasHechasPorUserEscribir[userID].numReservas = dbReservasHechasPorUserEscribir[userID].numReservas -1;
            } else {
              delete dbReservasHechasPorUserEscribir[userID];
            } 
            await escribirDatos(6);
          }
        });
      }
    }
  }
}, 900000);


/*-------------------------------------------------- */
/*Datos de actualización del status del bot y recursos. */
client.on('ready', async () => {
  setInterval(async () => {
    arrTiempo = sacarTiempoOn(); /*Semana, dias , horas, minutos y segundos */
    const index = Math.floor(Math.random() * ((actividades.length-1) - 0 + 1)) + 0; // Genera un numero aleatorio entre 1 y la longitud de la lista de actividades.
    client.user.setPresence({ activities: [{ name: `${actividades[index]}` }], status: 'online' });
    const guild = await  client.guilds.resolve(guildID);
    const ch = await guild.channels.resolve(MensajeStatus[0]);
    const categoria = await client.channels.resolve(parentTempChannels);
    let cantidadTempchannels = categoria.children.cache.size;
    await ch.messages.fetch(MensajeStatus[1]).then(async msg =>{
      CPU.cpuUsage(async function(ConsumoCpu) {
        embedStatus = new EmbedBuilder()
        .setTitle(`Status del bot`)
        .setColor(`Aqua`)
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription(`Mensaje automáticamente actualizado por el bot donde informa del estado del bot, su consumo de recursos y otros datos importantes.`)
        .setTimestamp()
        .addFields({ name: 'Cantidad de reservas pendientes', value: `${Object.keys(dbReservasEscribir).length}`, inline: true },
                  { name: `Cantidad de tickets abiertos:`, value: `${Object.keys(dbServeraUserEscribir).length}`, inline: true },
                  { name: `Consumo de cpu`, value: '``'+(ConsumoCpu*100)+'``', inline: true},
                  { name: `Consumo de RAM: `, value:  '``' + (os.totalmem() - os.freemem()) / os.totalmem()* 100 + '%``', inline: true},
                  { name: `Plataforma: `, value: os.platform(), inline: true},
                  { name: `Uptime:`, value: arrTiempo[0] + ' ``w`` ' + arrTiempo[1] + ' ``d`` ' + Math.round(arrTiempo[2]) + ' ``h`` ' + Math.round(arrTiempo[3]) + ' ``m`` ' + Math.round(arrTiempo[4]) + ' ``s``-> (' +client.uptime + ' ``ms``)'  },
                  { name: `Cantidad de tempchannels: `, value: '``' + cantidadTempchannels+ ' ``', inline: true}
                  )
        await msg.edit({embeds: [embedStatus]})
      });
    });
  }, 30000);
});

/*-------------------------------------------------*/
const { REST, Routes } = require('discord.js');


const commands = [
  /* Torneos */
  {
    name: 'finalizarplazoinscripcion',
    description: 'Finalizas el plazo de inscripción a un torneo',
    options: [
      {
        name: 'nombre',
        description: 'Nombre del torneo a finalizar plazo de inscripción',
        type: 3,
        required: true
      }
    ]
  },
  {
    name: 'establecerdbtorneo',
    description: 'Estableces un torneo en la database',
    options: [
      {
        name: 'tipo',
        description: 'Individual: 0, Parejas: 1',
        type: 4,
        required: true
      },
      {
        name: 'nombre',
        description: 'Nombre del torneo con el que la gente se deberá apuntar única palabra para evitar errores',
        type: 3,
        required:true
      }
    ]
  },
  {
    name: 'torneo',
    description: 'Operaciones relacionadas con un torneo.',
    options: [
      {
        name: "apuntarse",
        description: 'Te apuntas a un torneo específico',
        type: 2,
        options:[
          {
            name: 'individual',
            description: 'Te apuntas a un torneo individual',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo individual en el que quieres participar.',
                required: true
              }, 
              {
                name: 'correo',
                type: 3,
                description: 'Correo institucional personal', 
                required: true
              }
            ]
          },
          {
            name: 'parejas',
            description: 'Te apuntas a un torneo en parejas',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo parejas en el que quieres participar.',
                required: true
              },
              {
                name: 'correo',
                type: 3,
                description: 'Correo institucional personal', 
                required: true
              },
              {
                name: 'companero',
                type: 6,
                description: 'Persona con la que te inscribes. Si no tienes a nadie te emparejaremos manualmente.',
                required: false
              }, 
              {
                name: 'correocompanero',
                type: 3,
                description: 'Correo institucional personal de tu pareja', 
                required: false
              }
            ]
          }
        ]
      },
      {
        name: "desapuntarse",
        description: 'Te desapuntas a un torneo específico',
        type: 2,
        options:[
          {
            name: 'individual',
            description: 'Te desapuntas a un torneo individual',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo individual en el que quieres desapuntarte.',
                required: true
              }
            ]
          },
          {
            name: 'parejas',
            description: 'Te desapuntas a un torneo en parejas',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo parejas en el que quieres desapuntarte.',
                required: true
              }
            ]
          }
        ]
      }
    ]
  },
  /* Reglamento */
  {
    name: 'reglamentoindividual',
    description: 'Envías el reglamento en un canal determinado',
    options: [{
      name: 'channel',
      type: 7,
      required: true, 
      description: 'Canal donde debo enviarlo'
    }]
  },
  /* Reglas */
  {
    name: 'reglas',
    description:'Envias el mensaje de reglas del servidor',
    options: [
      {
        name: 'channel',
        type: 7,
        required: true,
        description: 'Canal donde envias las reglas del servidor'
      }
    ]
  },
  /* FAQ */
  {
    name: 'enviarfaq',
    description: 'Envías las faq a un canal determinado',
    options: [{
      name: 'canal',
      type: 7,
      description: 'Lugar donde quieres enviar los FAQ',
      required: true
    },
    {
      name: 'opcion',
      type: 4,
      description: 'Eliges la opcion de la que quieres los faq.',
      required: true
    }
    ]
  },
  /* TempChannels */
  {
    name: 'creartempchannels',
    description: 'Creas un canal como tempchannel',
    options:[
      {
        name: 'canal',
        description: 'Canal que estableces como tempchannel',
        type: 7,
        required: true
      },
      {
        name: 'cantidaduser',
        description: 'Cantidad de usarios para el canal',
        type: 4,
        required: false
      }
    ]
  },
  /* Crear eventos */
  {
    name: 'crearevento',
    description: 'Creas un evento en el servidor de discord',
    options: [{
      name: 'titulo',
      required: true,
      description: 'Titulo del eveto',
      type: 3
    },
    {
      name: 'descripcion',
      description: 'Descripción del evento',
      type: 3,
      required: true
    },
    {
      name: 'fechainicio',
      required: true,
      description: 'Formato dd/mm',
      type: 3
    },
    {
      name: 'fechafin',
      required: true,
      description: 'Formato dd/mm',
      type: 3
    },
    {
      name: 'location',
      type: 3,
      description: 'Localización, por default la escuela.',
      required: false
    }]
  },
  /* say*/
  {
    name: 'say',
    description: 'dices algo con el bot',
    options: [
      {
        name: 'content',
        description: '¿Qué quieres decir?',
        type: 3,
        required: true
      }
    ]
  },
  /* Info sobre bots */
  {
    name: 'musicbot',
    description: 'Muestras información básica de ayuda sobre el bot de musica.'
  },
  /* Sugerencias*/
  {
    name: 'denegarsugerencia',
    description: 'Deniegas una sugerencia',
    options: [{
      name: 'idsugerencia',
      type: 3,
      description: 'Id de la sugerencia que quieres denegar',
      required: true
    },
    {
      name: 'reason',
      description: 'Razón por la cual deniegas la sugerencia',
      type: 3,
      required: true
    }]
  },
  {
    name: 'sugerenciaimplementada',
    description: 'Marcas como implementada la sugerencia.',
    options: [
      {
        name: 'idsugerencia',
        description: 'Id de la sugerencia implementada',
        type: 3,
        required: true
      }
    ]
  },
  {
    name: 'sugerir',
    description: 'realizas una sugerencia',
    options:[{
      name: 'contenido',
      description: 'sugerencia',
      type: 3, 
      required: true
    },
    {
      name: 'adjunto',
      type: 11,
      description: 'Posible contenido adjunto.',
      required: false
    }]
  },
  /*Embeds automáticos para el reaction role*/
  {
    name: 'reactionroleembeds',
    description: 'Envías los mensajes.', 
    options:[{
      name: 'canal',
      description: 'Canal donde vas a enviar la información',
      type: 7,
      required: true
    }]
  },
  /*Generar invite eterna a un servidor donde generes el comando*/
  {
    name: 'generarinvite',
    description: 'Generas invite'
  }, 
  /* Status del desarrollo */
  {
    name: 'status',
    description: 'Muestras el status del bot'
  },
  /*Reserva de mesas*/
  {
    name: 'ping',
    description: 'Muestras el ping del bot',
  },
  {
    name: 'reservamesa',
    description: 'Solicitud de reserva de mesa.',
    options: [{
      name: 'fecha',
      description: 'Proporciona la fecha en formato dd/mm. Solo puedes reservar con 6 meses de antelación',
      type: 3,
      required: true
    },
    {
      name: 'horainicio',
      description: 'Proporciona la hora en formato 24 horas con hh:mm',
      type: 3,
      required: true
    },
    {
      name: 'horafin',
      description: 'Proporciona la hora en formato 24 horas con hh:mm',
      type: 3,
      required: true
    },
    {
      name: 'mesa',
      description: 'Elijes el número de mesa a reservar.',
      type: 4,
      required: false
    }]
    
  },
  {
    name: 'cancelarreserva',
    description: 'Cancelas una reserva que tenías programada.',
    options: [{
      name: 'fecha',
      description: 'Proporciona la fecha de tu reserva en formato dd/mm',
      type: 3, 
      required: true
    }]
  },
  {
    name: 'mostrarreservas',
    description: 'Muestras la información de las reservas en una fecha determinada.',
    options: [{
      name: 'fecha',
      description: 'Proporciona la fecha a consultar',
      type: 3,
      required: true
    }]
  },
  {
    name: 'borrarreserva',
    description: 'Borras la mesa de un usuario en una determinado fecha y hora. El usuario recibirá la razón.',
    options:[{
      name: 'user',
      type: 6,
      required: true,
      description: 'Usuario titular de la reserva'
    },
    {
      name: 'fecha',
      description: 'Fecha en la que está planificada la reserva',
      type: 3,
      required: true
    },
    {
      name: 'reason',
      description: 'Razón por la cual cancelas la reserva.',
      type: 3,
      required: true
    }]
  },

  /* Reaction role */
  {
    name: 'addreactionrole',
    description: 'Creas un reaction role. Luego te pedirá que reacciones con el emoji deseado.',
    options: [{
      name: 'messageid',
      description: 'ID del mensaje para el reaction role',
      type: 3,
      required: true
    },
    {
      name: 'role',
      description: 'Role a entregar',
      type: 8, /*Guardamos un tipo String ya que los posibles salvados numéricos no son lo suficientemente grandes */
      required: true
    },
    {
      name: 'canalmensaje',
      description: 'Canal donde está situado el mensaje del reactionrole',
      type: 7,
      required: true
    }]
  },
  {
    name: 'removereactionrole',
    description: 'Eliminas un reaction role',
    options: [{
      name: 'messageid',
      description: 'ID del mensaje para el reaction role',
      type: 3,
      required: true
    },
    {
      name: 'canalmensaje',
      description: 'Canal donde está situado el mensaje del reactionrole',
      type: 7,
      required: true
    }]
  },
  /* Modmail*/
  {
    name: 'reply',
    description: 'Respondes a un mensaje en modmail',
    options: [{
      name: 'contenido',
      description: 'Contenido de texto que respondes al usuario',
      type: 3,
      required: true
    },
    {
      name:'adjunto',
      description: 'Posible contenido adjunto',
      type: 11,
      required: false
    }]
  },
  {
    name: 'contactar',
    description: 'Inicias un contacto de modmail con un usuario.',
    options: [
      {
        name: 'user',
        description: 'Usuario al que quieres contactar',
        type: 6,
        required: true
      },
      {
        name: 'reason',
        description: 'Razón del contacto\nLa razón la recibe el usuario.',
        type: 3,
        required: true
      }
    ]
  },
  {
    name: 'cerrarticket',
    description: 'Cierras un ticket en curso'
  },
  {
    name: 'bloquearuser',
    description: 'Bloqueas a un usuario del uso del modmail',
    options: [{
      name: 'user',
      description: 'user al que aplicas el ban',
      required: true,
      type: 6
    },
    {
      name: 'reason',
      description: 'Razón a la que se debe el ban',
      required: true,
      type: 3
    }]
  },
  {
    name: 'editarmensajeticket',
    description: 'Editas un mensaje de un ticket enviado por el staff',
    options:[{
      name: 'newcontent',
      description: 'Nuevo contenido en el mensaje a editar',
      type: 3,
      required: true
    },
    {
      name: 'idmensaje',
      description: 'La id del mensaje a editar en el servidor',
      type: 3,
      required: true
    }]
  },
  {
    name: 'desbloquearuser',
    description: 'Desbloqueas a un usuario del uso del modmail',
    options: [{
      name: 'user',
      description: 'El usuario al que quieres desbloquear',
      type: 6,
      required: true
    }]
  }
];

const rest = new REST({ version: '10' }).setToken(token);

try {
  console.log('Recargando slash commands.');

   //rest.put(Routes.applicationCommands(CLIENT_ID), { body: commands }); Esto lo hace en todo tanto md's como servidor.
   rest.put(Routes.applicationGuildCommands(CLIENT_ID, guildID), { body: commands }); /*Creamos únicamente en el guild, esto es para que no se creen en el md y otros servidores. */



  console.log('Slash Commands recargados');
} catch (error) {
  console.error(error);
}
const actividades = ["Ping",  "Pong"];

/*client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});*/
/* SLASH COMMANDS */
client.on('interactionCreate', async interaction => {
  if (!interaction.isChatInputCommand()) return;
  if(bloqueadosModmailEscribir[interaction.member.id])
    return interaction.reply({content: `Estás bloqueado del uso del bot`, ephemeral: true});
  if (interaction.commandName === 'ping') {
    await interaction.reply({content: `🏓 Pong actual: ${Math.abs(Date.now() - interaction.createdAt)}` , ephemeral: true});
  } else if(interaction.commandName == 'reservamesa'){
    let fechaInicio = await interaction.options.getString('fecha');
    let horaInicio = await interaction.options.getString('horainicio');
    let horaFin = await interaction.options.getString('horafin');
    if(dbReservasHechasPorUserEscribir[interaction.member.id]){
      if(dbReservasHechasPorUserEscribir[interaction.member.id].numReservas >= numeroMáximoReservasUser && adminsIDS.indexOf(interaction.member.id) == -1)
        return interaction.reply({content: "Has hecho tu número máximo de reservas espera a haber realizado tu reserva.\n Si crees que se trata de un error escríbeme un md", ephemeral: true});
    }
    if(horaInicio> horaFin)
      return interaction.reply({content: 'La colocación de las horas es incorrecta.', ephemeral: true});
    let mesa = await interaction.options.getInteger('mesa');
    if((mesa <1 || mesa > numMesas) && mesa !=null ) return interaction.reply('La mesa no existe');
    if(!(verificarHoras(horaInicio) && verificarHoras(horaFin) && verificarFecha(fechaInicio)))
      return interaction.reply('Formato de fechas o horas incorrecto, verifica que la fecha está en formato dd/mm y la hora hh:mm. \n En caso de haberlo proporcionado bien únicamente puedas reservar con seis meses de antelación.');
    if(!verificarTiempoantelacion(fechaInicio) && adminsIDS.indexOf(interaction.member.id) == -1) //Debe no ser admin y menos de 24 horas.
      return interaction.reply({content: `Debes reservar con más de 24 horas de antelación.`});
    if(dbReservasEscribir[fechaInicio]){
      mesa = (mesa == null) ? buscarMesa(horaInicio, horaFin, dbReservasEscribir[fechaInicio]) : verificarMesa(mesa, fechaInicio, horaInicio, horaFin);
      if(mesa == -1){
        return interaction.reply({content : 'No disponible la mesa en específico o ese horario en general.', ephemeral: true});
     }
     if(member(interaction.member.id, dbReservasEscribir[fechaInicio].arrayUserID,0))
      return interaction.reply('No puedes tener más de una reserva en un día.');
     dbReservasEscribir[fechaInicio].arrayHoraInicio = anadirDelArray(dbReservasEscribir[fechaInicio].arrayHoraInicio, horaInicio, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].arrayHoraFin = anadirDelArray(dbReservasEscribir[fechaInicio].arrayHoraFin, horaFin, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].arrayMesas = anadirDelArray(dbReservasEscribir[fechaInicio].arrayMesas, mesa, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].arrayUserID = anadirDelArray(dbReservasEscribir[fechaInicio].arrayUserID, interaction.member.id, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].longitud = dbReservasEscribir[fechaInicio].longitud +1; 
     escribirDatos(1);     
    } else {
      if(mesa < 0 || mesa > numMesas){
        return interaction.reply('Esa mesa no existe');
      }
      mesa = (mesa == null) ? 1: mesa;
      arrayHoraInicio = [horaInicio];
      arrayHoraFin = [horaFin];
      arrayMesas = [1];
      arrayUserID = [interaction.member.id];
      longitud = 1;
      dbReservasEscribir[fechaInicio] = {arrayHoraInicio, arrayHoraFin, arrayMesas, arrayUserID, longitud};
      escribirDatos(1);      
    }
    numReservas = !(dbReservasHechasPorUserEscribir[interaction.member.id])? 1: dbReservasHechasPorUserEscribir[interaction.member.id].numReservas+1;
    dbReservasHechasPorUserEscribir[interaction.member.id] = {numReservas}
    await escribirDatos(6)

    interaction.reply('Reserva con éxito').then(async msg =>{
       /*Intentamos escribir un md al usuario para informarle de su reserva de ping pong, con el riesgo de que el usuario no tenga abiertos los md con el bot, luego realizamos un try{} catch.
        En caso de que no pueda localizar por md, lo envía al canal donde se ejecutó el comando.
       */
      try{
          usuarioReserva = await client.users.fetch(interaction.member.id);
          const embedReserva = new EmbedBuilder()
          .setColor('Green')
          .setTitle('Información de reserva de la mesa de ping pong.')
          .setAuthor({name: interaction.member.displayName, avatarURL: interaction.member.avatarURL()})
          .setDescription(`Mesa ${mesa}`)
          .addFields({name: 'Cuenta de discord titular de la reserva:', value: interaction.member.displayName }, {name: 'Fecha de inicio: ', value: fechaInicio}, {name: 'Hora de inicio:', value: horaInicio}, {name: 'Hora de finalización:', value: horaFin}, {name: 'Reserva realizada con éxito.',  value: '\u200B'})
          .setFooter({ text: '🏓 Buenas partidas 🏓', iconURL: client.user.avatarURL()});
          await usuarioReserva.send({ embeds: [embedReserva] });
      }catch(error){
        const embedReserva = new EmbedBuilder()
          .setColor('Green')
          .setTitle('Información de reserva de la mesa de ping pong.')
          .setAuthor({name: interaction.member.displayName, avatarURL: interaction.member.avatarURL()})
          .setDescription(`Mesa ${mesa}`)
          .addFields({name: 'Cuenta de discord titular de la reserva:', value: interaction.member.displayName }, {name: 'Fecha de inicio: ', value: fechaInicio}, {name: 'Hora de inicio:', value: horaInicio}, {name: 'Hora de finalización:', value: horaFin}, {name: 'Reserva realizada con éxito.',  value: '\u200B'})
          .setFooter({ text: '🏓 Buenas partidas 🏓', iconURL: client.user.avatarURL()});
          msg.edit({content: 'No he podido localizarte por md, seguramente tendrás bloqueados los mensajes directos de este servidor, adjunto información de la reserva por aquí.\nNota: Información de discord para permitir mensajes directos de este servidor. [Pulsa aquí.](https://support.discord.com/hc/es/articles/217916488-Ajustes-de-bloqueo-y-privacidad#h_01HD4ANCTGAS1RCVZVY1F4CHGS)', embeds: [embedReserva]});
      }
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[1]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { User: `${interaction.member.displayName} -> (${interaction.member.id})`, Fecha: `${fechaInicio}`,  Hora_Inicio: `${horaInicio}`, Hora_Fin: `${horaFin}`, Mesa: mesa}
        ]);
      }catch(error){
        console.log(error)
      }
    });
   
  } else if(interaction.commandName === 'cancelarreserva'){
    let fecha = interaction.options.getString('fecha');
    if(!verificarFecha(fecha))
      return interaction.reply('Fecha en formato erróneo. Debe ser en formato dd/mm\nEn caso de tener buen formato puedes consultar como máximo en un transcurso de seis meses.');
    if(dbReservasEscribir[fecha]){
      
      if(member(interaction.member.id,dbReservasEscribir[fecha].arrayUserID, 1)){
        /*Este usuario tenía una reserva para esa fecha.*/
        if(dbReservasEscribir[fecha].longitud == 1){
          /*Únicamente ese usuario tenía reserva para esa fecha, luego hay que borrar todo */
          delete dbReservasEscribir[fecha];
          escribirDatos(1);
        } else{
          /*No solamente está ese usuario de reserva */
          /*Necesitamos saber en qué posición para borrar esa reserva */
          let pos = dbReservasEscribir[fecha].arrayUserID.indexOf(interaction.member.id);
          dbReservasEscribir[fecha].arrayHoraInicio = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraInicio, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayHoraFin = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraFin, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayMesas = eliminarDelArray(dbReservasEscribir[fecha].arrayMesas, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayUserID = eliminarDelArray(dbReservasEscribir[fecha].arrayUserID, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].longitud = dbReservasEscribir[fecha].longitud -1;
          escribirDatos(1);
          
        }
        numReservas = dbReservasHechasPorUserEscribir[interaction.member.id].numReservas -1;
        if(numReservas != 0){
          dbReservasHechasPorUserEscribir[interaction.member.id] = {numReservas};
          escribirDatos(6);
        } else {
          delete dbReservasHechasPorUserEscribir[interaction.member.id];
          escribirDatos(6);
        }
        await interaction.reply('Reserva cancelada con éxito.').then(async msg =>{
          try{
            usuarioReserva = await client.users.fetch(interaction.member.id);
            await usuarioReserva.send({content: 'Su reserva ha sido cancelada con éxito para la fecha: ' + fecha});
          } catch(e){
            await msg.edit({content: 'No he podido localizarte por md, seguramente tendrás bloqueados los mensajes directos de este servidor, adjunto información de la reserva por aquí.\nNota: Información de discord para permitir mensajes directos de este servidor. [Pulsa aquí.](https://support.discord.com/hc/es/articles/217916488-Ajustes-de-bloqueo-y-privacidad#h_01HD4ANCTGAS1RCVZVY1F4CHGS) \nSu reserva ha sido cancelada con éxito para la fecha: ' + fecha});
          }
        });
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[1];
        const userBorrar = `${interaction.member.displayName} -> (${interaction.member.id})`;
        const fechaaborrar = `${fecha}`
        /* Vamos a intentar borrar por nombre. */
        await sheet.loadCells();
        // Encontrar y eliminar la fila
        const rows = sheet.rowCount;
        continuar = true;
        for (let i = 0; i < rows && continuar; i++) {
          const cell1 = sheet.getCell(i, 0); 
          const cell2 = sheet.getCell(i, 1)
          if (cell1.value === userBorrar && cell2.value == fechaaborrar) {
            sheet.clearRows({start: i+1, end: i+1});
            continuar = false;
          }
        } 
        
      } else {
        return interaction.reply('No tiene ninguna reserva en esa fecha.');
      }
    }else {
      return interaction.reply('No había ninguna reserva en esa fecha.');
    }
  }else if(interaction.commandName === 'mostrarreservas'){
    let fecha = await interaction.options.getString('fecha');
    if(!(verificarFecha(fecha)))
      return interaction.reply('Fecha en formato erróneo.\nEn caso de haberlo puesto en formato correcto como máximo puedes consultar en seis meses de distancia.');
    if(dbReservasEscribir[fecha]){
      var texto = await mostrarInformacionReservas(dbReservasEscribir[fecha]);
      const embedReservas = new EmbedBuilder()
      .setColor('Green')
      .setTitle(`Información de la reserva en la fecha: ${fecha}`)
      .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
      .setDescription(texto)
      .addFields({name: `Puedes ver en tiempo real en este enlace como están las reservas: `, value: `[Google Sheets](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)`})
      .setTimestamp()
      interaction.reply({embeds: [embedReservas]});
    }else {
      /*Caso  de que no haya reserva en esa fecha*/
      interaction.reply({content: 'No hay ninguna reserva para esa fecha.\nPuedes ver en tiempo real las reservas a través del siguiente [Google Sheets](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)'});
    }

  } 
  /*Reaction role. */
  else if(interaction.commandName == 'addreactionrole'){
    try{
      let messageid = await interaction.options.getString('messageid');
      let role = await interaction.options.getRole('role');
      let canal = await interaction.options.getChannel('canalmensaje');
      const channel = await client.channels.fetch(canal.id);
      const mensaje = await channel.messages.fetch(messageid);
      const roleEntregar = await interaction.guild.roles.fetch(role.id);
      const botServer = await interaction.guild.members.fetch(client.user.id);
      await botServer.roles.add(role.id);
      if(channel.type != 0)
        return interaction.reply('Solo puedo hacer reactions role en canales de texto normales.\nNo puedo en threads.');
      const msg = await interaction.reply({content: 'Reacciona en este mensaje el emoji al que deben reaccionar. \nSolo dispones de 1 minuto para ello.', fetchReply: true });
      const filter = (reaction, user) => {
        user.id === interaction.member.id && msg.id === reaction.message.id;
      };
      var salvado = false; // Salvaguarda para solo guardar un emoji por comando.
      const Collector = msg.createReactionCollector(filter, { time: 120000, max: 1 });
      Collector.on('collect', async reaction => {
        emoji = (reaction.emoji.id== null) ? reaction.emoji.name : reaction.emoji.id;
        if(salvado) return;
        if(dbReactionRoleEscribir[mensaje.id]){
          if( dbReactionRoleEscribir[mensaje.id].canalID === channel.id){
            /*Este mensaje ya poseía algún reaction role anterior.*/
            dbReactionRoleEscribir[mensaje.id].emojis = anadirDelArray(dbReactionRoleEscribir[mensaje.id].emojis, emoji, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].role = anadirDelArray(dbReactionRoleEscribir[mensaje.id].role, roleEntregar.id, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].longitud = dbReactionRoleEscribir[mensaje.id].longitud+1;
            await escribirDatos(2);
          }
        } else {
          emojis = [emoji];
          role = [roleEntregar.id];
          var canalID = channel.id;
          longitud = 1;
          dbReactionRoleEscribir[mensaje.id] = {canalID, emojis, role, longitud};
          await escribirDatos(2);
        }
        await mensaje.react(emoji);
        await interaction.editReply({content: 'ReactionRole establecido con éxito', ephemeral: true});
        salvado = true;
      });

    } catch(error){
      /*Devuelve al usuario el error que se ha cometido:
        Pendiente para el github hacer una lista de los posibles errores y solución.
      */
      await interaction.reply({content: 'Se ha produciodo el siguiente error: \n' + error + '\nConsulta la documentación en github en búsqueda de una posible solución.', ephemeral: true});
    }
  } else if(interaction.commandName == 'removereactionrole'){
    try {
      let messageid = await interaction.options.getString('messageid');
      let canal = await interaction.options.getChannel('canalmensaje');
      const channel = await client.channels.fetch(canal.id);
      const mensaje = await channel.messages.fetch(messageid);
      if(dbReactionRoleEscribir[mensaje.id] && dbReactionRole[mensaje.id].canalID == channel.id){
        //Existe en la database algunos de esos datos.
        // Ahora debo pedir el emoji que quieren que elimine.
        const msg = await interaction.reply({content: 'Reacciona en este mensaje el emoji al que deben reaccionar. \nSolo dispones de 1 minuto para ello.', fetchReply: true });
        const filter = (reaction, user) => {
          user.id === interaction.member.id && msg.id === reaction.message.id;
        };
        var salvado = false; // Salvaguarda para solo guardar un emoji por comando.
        const Collector = msg.createReactionCollector(filter, { time: 120000, max: 1 });
        Collector.on('collect', async reaction => {
          emoji = (reaction.emoji.id== null) ? reaction.emoji.name : reaction.emoji.id;
          if(salvado) return;
          if(dbReactionRoleEscribir[mensaje.id].longitud == 1){
            //Debo borrarlo de la database al completo.
            delete dbReactionRoleEscribir[mensaje.id];
            await escribirDatos(2);
          } else {
            // Mantenemos otros datos en la db.
            var pos = dbReactionRoleEscribir[mensaje.id].emojis.indexOf(emoji);
            dbReactionRoleEscribir[mensaje.id].emojis = eliminarDelArray(dbReactionRole[mensaje.id].emojis, pos, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].role = eliminarDelArray(dbReactionRole[mensaje.id].role, pos, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].longitud = dbReactionRoleEscribir[mensaje.id].longitud-1;
            await escribirDatos(2);
          }
          await interaction.editReply({content: 'Reaction role eliminado con exito.', ephemeral: true});
      });
      } else {
        interaction.reply({content: 'No existe ningún reaction role con esos datos en la database.', ephemeral: true});
      }
    }catch(error){

    }
  } else if(interaction.commandName === 'borrarreserva'){
    const user = interaction.options.getUser('user');
    const userFetched = await client.users.fetch(user.id);
    const fecha = interaction.options.getString('fecha');
    const reason = interaction.options.getString('reason');
    try{
      if(!verificarFecha(fecha))
        return interaction.reply({content: 'Fecha en formato incorrecto', ephemeral: true});
      if(dbReservasEscribir[fecha]){
        if(dbReservasEscribir[fecha].arrayUserID.indexOf(userFetched.id) == -1)
          return interaction.reply({content: `El ${userFetched.displayName} no tiene reserva en esa fecha.`, ephemeral: true});
        if(dbReservasEscribir[fecha].longitud == 1){
          /*Únicamente ese usuario tenía reserva para esa fecha, luego hay que borrar todo */
          delete dbReservasEscribir[fecha];
          escribirDatos(1);
        } else{
          /*No solamente está ese usuario de reserva */
          /*Necesitamos saber en qué posición para borrar esa reserva */
          let pos = dbReservasEscribir[fecha].arrayUserID.indexOf(userFetched.id);
          dbReservasEscribir[fecha].arrayHoraInicio = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraInicio, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayHoraFin = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraFin, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayMesas = eliminarDelArray(dbReservasEscribir[fecha].arrayMesas, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayUserID = eliminarDelArray(dbReservasEscribir[fecha].arrayUserID, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].longitud = dbReservasEscribir[fecha].longitud -1;
          escribirDatos(1);  
        }
      const guild = await client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedReservaBorrada = new EmbedBuilder()
      .setTitle(`Ticket cerrado`)
      .addFields({name: 'User', value:`${userFetched.displayName} -> (${userFetched.id})`},
                 {name: 'Staff', value: `${interaction.member.displayName}->(${interaction.member.id})`},
                 {name: 'Razón', value: reason}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedReservaBorrada]});
      await userFetched.send(`Su reserva para la fecha ${fecha} fue cancelada por ${interaction.member.displayName} debido a ${reason}`);
      interaction.reply({content: `Reserva cancelada con exito`, ephemeral: true});
      const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[1];
        const userBorrar = `${interaction.member.displayName} -> (${interaction.member.id})`;
        const fechaaborrar = `${fecha}`
        /* Vamos a intentar borrar por nombre. */
        await sheet.loadCells();
        // Encontrar y eliminar la fila
        const rows = sheet.rowCount;
        continuar = true;
        for (let i = 0; i < rows && continuar; i++) {
          const cell1 = sheet.getCell(i, 0); 
          const cell2 = sheet.getCell(i, 1)
          if (cell1.value === userBorrar && cell2.value == fechaaborrar) {
            sheet.clearRows({start: i+1, end: i+1});
            continuar = false;
          }
        } 
        numReservas = dbReservasHechasPorUserEscribir[interaction.member.id].numReservas -1;
        if(numReservas != 0){
          dbReservasHechasPorUserEscribir[interaction.member.id] = {numReservas};
          escribirDatos(6);
        } else {
          delete dbReservasHechasPorUserEscribir[interaction.member.id];
          escribirDatos(6);
        }
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          const reservaSheet = await sheet.addRows([
            { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Borrar Reserva a ${user.displayName} -> (${user.id}).`, Reason: reason}
          ]);
        }catch(error){
          console.log(error)
        }
      } else {
        return interaction.reply({content: `No hay ninguna reserva en la fecha ${fecha}`});
      }
      
    }catch(error){
      interaction.reply(error);
    }
  }
   /* Modmail */
  else if(interaction.commandName === 'reply'){
    try{
      if(!dbServeraUserEscribir[interaction.channel.id])
        return interaction.reply({content: `Este canal de texto ${interaction.channel}, no está registrado como modmail.`, ephemeral: true});
      if(bloqueadosModmailEscribir[dbServeraUserEscribir[interaction.channel.id].idUser])
        return interaction.reply({content: `No puedes escribir a un usuario bloqueado`, ephemeral: true});
      const contenido = interaction.options.getString('contenido');
      var usuarioID =  dbServeraUserEscribir[interaction.channel.id].idUser;
      const user = await client.users.fetch(dbServeraUserEscribir[interaction.channel.id].idUser);
      const ch = interaction.channel;
      await user.send(contenido).then(async msg =>{
        await ch.send(`**STAFF**: \n ${interaction.member.displayName}`);
        const mensajeEnServer = await ch.send(contenido);
        var idMensajeEnUser = msg.id;
        var idMensajeEnServer = mensajeEnServer.id;
        dbUseraServerEscribir[usuarioID].mensajesEnUser = anadirDelArray(dbUseraServerEscribir[usuarioID].mensajesEnUser, idMensajeEnUser, dbUseraServerEscribir[usuarioID].longitud);
        dbUseraServerEscribir[usuarioID].mensajesEnServer = anadirDelArray(dbUseraServerEscribir[usuarioID].mensajesEnServer, idMensajeEnServer, dbUseraServerEscribir[usuarioID].longitud);
        dbUseraServerEscribir[usuarioID].longitud = dbUseraServerEscribir[usuarioID].longitud +1;
        dbServeraUserEscribir[ch.id].mensajesEnUser= dbUseraServerEscribir[usuarioID].mensajesEnUser;
        dbServeraUserEscribir[ch.id].mensajesEnServer = dbUseraServerEscribir[usuarioID].mensajesEnServer;
        dbServeraUserEscribir[ch.id].longitud = dbUseraServerEscribir[usuarioID].longitud;
        await escribirDatos(3);
        await escribirDatos(4);
        await interaction.reply({content: 'Funcionó correctamente', ephemeral: true});
        if(interaction.options.getAttachment('adjunto') != null){
          /*Significa que hay un adjunto en el código.*/
          const adjunto = interaction.options.getAttachment('adjunto').url;
          await ch.send(adjunto);
          await user.send(adjunto);
        }
        await ch.setTopic(`Ticket pendiente de la respuesta del usuario. \n Última interaccion ${new Date()}`);
      });
    } catch(error){
      interaction.reply({content: `Se ha producido el siguiente error: ${error}`, ephemeral: true});
    }
  } else if(interaction.commandName === 'contactar'){
    const user = await interaction.options.getUser('user');
    if(user.bot)
      return interaction.reply({content: `No puedes contactar a un bot`, ephemeral: true});
    if(bloqueadosModmailEscribir[user.id])
      return interaction.reply({content: `No puedes escribir a un usuario bloqueado.`, ephemeral: true});
    try{
      if(dbUseraServerEscribir[user.id])
        return interaction.reply({content: `El usuario ${user.displayName} ya tiene un ticket en curso en el canal <#${dbUseraServerEscribir[user.id].idChannel}>`, ephemeral: true});
      const userFetch = await  client.users.resolve(user.id);
      const guild = await client.guilds.resolve(guildID);
      await guild.channels.create({name: `ticket-${user.displayName}`, parent: categoriaTicketsID, topic: `Ticket pendiente de la respuesta del staff. \n Última interaccion ${new Date()}`}).then(async ch =>{
        const embedNuevoTicket = new EmbedBuilder()
        .setTitle(`Los staffs del servidor le han contactado`)
        .setAuthor({name: client.user.displayName, avatarURL: client.user.displayAvatarURL})
        .setColor('Green')
        .setDescription(`El contacto se produce desde el server ${guild.name}.`)
        .setTimestamp()
        await userFetch.send({embeds: [embedNuevoTicket]});
        const contenido = await interaction.options.getString('reason');
          await userFetch.send(contenido).then(async msg =>{
            await ch.send(`**STAFF**: \n ${interaction.member.displayName}`);
            const mensajeEnServer = await ch.send(contenido);
            var mensajesEnUser = [msg.id];
            var mensajesEnServer = [mensajeEnServer.id];
            var idChannel = ch.id;
            var longitud = 1;
            var idUser = user.id;
            dbUseraServerEscribir[user.id] = {idChannel, mensajesEnUser, mensajesEnServer, longitud};
            dbServeraUserEscribir[ch.id] = {idUser, mensajesEnUser, mensajesEnServer, longitud};
            await escribirDatos(3);
            await escribirDatos(4);
          });
        await interaction.reply({content: `Ticket generado con éxito.\nEl canal de contacto es: ${ch}`, ephemeral: true});
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          const reservaSheet = await sheet.addRows([
            { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Usuario contactado: ${userFetch.displayName} -> (${userFetch.id}).`, Reason: `${contenido}`}
          ]); 
        }catch(error){
          console.log(error)
        }
      });

    } catch (error){
      interaction.reply({content: `Se ha producido un error ${error}`, ephemeral: true})
    }
  } else if(interaction.commandName === 'cerrarticket'){
    if(!dbServeraUserEscribir[interaction.channel.id])
      return interaction.reply({content: `El canal no es de un ticket`, ephemeral: true});
    try{
      const guild = await client.guilds.resolve(guildID);
      const contenidoLogs = await guild.channels.resolve(logsTicket);
      const user = await client.users.fetch(dbServeraUserEscribir[interaction.channel.id].idUser);
      const fetched = await interaction.channel.messages.fetch().then(async messages => {// .messages.fetch o fetchMessages
        const salida = messages.map(m => `${new Date(m.createdAt).toLocaleString('en-US')} - ${m.author.tag}: ${m.attachments.size > 0 ? m.attachments.first().proxyURL : m.content}`).reverse().join('\n');
       // console.log('Salida \n' + salida); //Buffer.from(salida)
        const attachment = new AttachmentBuilder(Buffer.from(salida), {name: 'logsSoporte.txt', description: 'Logs del chat' }); /*, 'logsSoporte.txt'*/
        /*new AttachmentBuilder('C:\Users\Desktop\discord', { name: 'ticket.png' }) */
        await contenidoLogs.send({ content: `Ticket: ${user}⁣`, files: [attachment] });
      });
      /*Borramos de la base de datos */
      
      const embedCerrarTicket = new EmbedBuilder()
      .setTitle('Ticket cerrado')
      .setColor('Red')
      .setDescription('Un staff ha cerrado su ticket de contacto')
      .setTimestamp()
      await user.send({embeds: [embedCerrarTicket]});
      
      await delete dbUseraServerEscribir[dbServeraUserEscribir[interaction.channel.id].idUser];
      await delete dbServeraUserEscribir[interaction.channel.id];
      await escribirDatos(4);
      await escribirDatos(3);
       /*Borramos el canal de texto */
      await interaction.channel.delete();
      
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      await canalLogs.send(`a`);
      const embedCloseTicket = new EmbedBuilder()
      .setTitle(`Ticket cerrado`)
      .addFields({name: 'User', value:`${user.displayName} -> (${user.id})`},
                 {name: 'Staff', value: `${interaction.member.displayName}->(${interaction.member.id})`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedCloseTicket]});
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Ticket cerrado a ${user.displayName} -> (${user.id}).`, Reason: ` `}
        ]); 
      }catch(error){
        console.log(error)
      }
    }catch(error){
      interaction.reply({content: `Se ha producido un error. \n ${error}`, ephemeral: true})
    }
  } else if(interaction.commandName === 'bloquearuser'){
    try{
      const user = interaction.options.getUser('user');
      const userFetched = await client.users.fetch(user);
      const reason = interaction.options.getString('reason');
      if(userFetched.bot)
        return interaction.reply({content: `No se puede bloquear a un bot`, ephemeral: true})
      var userID = userFetched.id;
      var bloqueado = true;
      bloqueadosModmailEscribir[userID] = {bloqueado};
      await escribirDatos(5);
      await interaction.reply({content: `Usuario bloqueado con éxito.`});
      const guild = await client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedUnlocked = new EmbedBuilder()
      .setTitle(`Usuario bloqueado del modmail.`)
      .addFields({name: `Staff`, value: `${interaction.member.displayName} -> ${interaction.member.id}`},
                  {name: `Usuario afectado`, value: `${userFetched.displayName} -> ${userFetched.id}`},
                  {name: `Razón`, value: reason}  
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedUnlocked]});
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Usuario baneado: ${userFetched.displayName} -> (${userFetched.id}).`, Reason: `${reason}`}
        ]); 
      }catch(error){
        console.log(error)
      }
    } catch(error){
      console.log(error);
    }
    
  } else if(interaction.commandName === 'editarmensajeticket'){
    /* Nota: Si se edita mucho un mensaje puede generar errores intentando el bot enviar un mensaje demiasado largo */
    const newcontent = interaction.options.getString('newcontent');
    const idMensaje = interaction.options.getString('idmensaje');
    if(dbServeraUserEscribir[interaction.channel.id].mensajesEnServer.indexOf(idMensaje)!=-1){
      var pos = dbServeraUserEscribir[interaction.channel.id].mensajesEnServer.indexOf(idMensaje);
      var arr = dbServeraUserEscribir[interaction.channel.id].mensajesEnUser;
      /*Caso en el que mensaje se ha encontrado en la database. */
      const user = await client.users.resolve(dbServeraUserEscribir[interaction.channel.id].idUser);
      await user.createDM();
      const mensajeUser =  await user.dmChannel.messages.fetch(arr[pos]);
      const mensajeServer = await interaction.channel.messages.fetch(idMensaje);
      await mensajeUser.edit(newcontent);
      await mensajeServer.edit(`Nuevo contenido editado:\n${newcontent}\nContenido antes de la edición:\n${mensajeServer.content}`);
      await interaction.reply({content: 'Editado con éxito'})
      const guild = client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.resolve(canalLogsMd);
      const embedChange = new EmbedBuilder()
      .setTitle(`Mensaje en Modmail editado por parte del staff`)
      .addFields({name: 'User', value:`${message.author.displayName} -> (${message.author.id})`},
                 {name: 'Contenido anterior: (Puede ser null si el bot se apago y perdió el caché)', value: `${message.content}`},
                 {name: 'Nuevo contenido:', value: `${newcontent}`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedChange]});
    } else {
      await interaction.reply('Mensaje no encontrado');
    }
  } else if(interaction.commandName === 'status'){
    await interaction.reply({content: `Implementación del bot:\n✅ Reserva de mesas. \n✅ Reaction Role.\n✅ Modmail\n✅ Sugerencias \n✅ Tempchannels\n✅Torneos\n⏳ Stats`, ephemeral: true});
  } else if(interaction.commandName === 'desbloquearuser'){
    const user = interaction.options.getUser('user');
    const userFetched = await client.users.fetch(user);
    if(bloqueadosModmailEscribir[userFetched.id]){
      await delete bloqueadosModmailEscribir[userFetched.id];
      await escribirDatos(5);
      const guild = await client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      await interaction.reply({content: `Usuario desbloqueado con éxito`});
      const embedUnlocked = new EmbedBuilder()
      .setTitle(`Usuario desbloqueado del modmail.`)
      .addFields({name: `Staff`, value: `${interaction.member.displayName} -> ${interaction.member.id}`},
                 {name: `Usuario afectado`, value: `${userFetched.displayName} -> ${userFetched.id}`}  
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedUnlocked]});
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Usuario desbaneado: ${userFetched.displayName} -> (${userFetched.id}).`, Reason: ` `}
        ]); 
      }catch(error){
        console.log(error)
      }
    } else {
      interaction.reply({content: `El usuario <@!${userFetched.id}> no está bloqueado`, ephemeral: true});
    }
  }  /*Generar invite eterna a un servidor donde generes el comando*/
  else if(interaction.commandName === 'generarinvite'){
    const guildFetch = client.guilds.resolve(guildID);
    try{
      const ch = guildFetch.rulesChannel;
      await ch.createInvite({maxAge: 0, maxUses:0 });
      await interaction.reply({content:`Invite generado con éxito`, ephemeral: true});
    } catch(error){
      console.log(error);
      await interaction.reply({content: `Se ha producido un error ${error}`, ephemeral: true});
    }
  } else if(interaction.commandName === "reactionroleembeds"){
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(interaction.options.getChannel('canal').id);
    var embedColores = new EmbedBuilder()
    .setTitle(`🌈 Añade un color a tu usuario 🌈`)
    .setAuthor({name: client.user.username, iconURL: client.user.displayAvatarURL()})
    .setColor('DarkOrange')
    .setDescription('🔴 \n ```\nRojo```\n🟢\n```Verde```\n🔵\n```\nAzul```\n🟡\n```\nAmarillo```')
    .setFooter({ text: 'Reaction Role Colores', iconURL: client.user.bannerURL()});
    await ch.send({embeds: [embedColores]});
    var embedLevel = new EmbedBuilder()
    .setTitle(`🏓 Nivel aproximado de ping pong 🏓`)
    .setAuthor({name: client.user.username, iconURL: client.user.displayAvatarURL()})
    .setColor('DarkOrange')
    .setDescription('🆕\n ```Nuevo jugando``` \n 🔰\n ```Principiante``` \n ⁉️\n ```Intermedio``` \n 🏓\n ```Federado / Antiguo federado```')
    .setFooter({ text: 'Reaction Role Nivel', iconURL: interaction.guild.iconURL()});
    await ch.send({embeds: [embedLevel]});
    await interaction.reply({content: `Ok`, ephemeral: true});

  } /* Sugerencias */
  else if(interaction.commandName === 'sugerir'){
    const contenido = interaction.options.getString('contenido');
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(canalSugerencias);
    if(interaction.options.getAttachment('adjunto')){
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setImage(interaction.options.getAttachment('adjunto').url)
      .setTimestamp()
      await ch.send({embeds: [embedSugerencia]}).then(async msg =>{
        await msg.react('✅');
        await msg.react('🫥');
        await msg.react('❌');
        var user = interaction.member.id;
        var imagen = interaction.options.getAttachment('adjunto').url;
        dbSugerenciasEscribir[msg.id] = {user,contenido, imagen};
        await escribirDatos(7);
      });
    } else {
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setTimestamp()
      await ch.send({embeds: [embedSugerencia]}).then(async msg =>{
        await msg.react('✅');
        await msg.react('🫥');
        await msg.react('❌');
        var user = interaction.member.id;
        imagen = null;
        dbSugerenciasEscribir[msg.id] = {user, contenido, imagen};
        await escribirDatos(7);
      });
    }
    await interaction.reply("Sugerencia realizada con éxito");
  } else if(interaction.commandName === 'sugerenciaimplementada'){
    var idSugerencia = interaction.options.getString('idsugerencia');
    if(!dbSugerenciasEscribir[idSugerencia]) return interaction.reply({content: 'La sugerencia no existe', ephemeral: true});
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(canalSugerencias); 
    const msj = await ch.messages.fetch(idSugerencia);
    await msj.delete();
    const chImpl =  await guildFetch.channels.resolve(sugerenciasImpl);
    contenido = dbSugerenciasEscribir[idSugerencia].contenido;
    if(dbSugerenciasEscribir[idSugerencia].imagen != null){
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setImage(dbSugerenciasEscribir[idSugerencia].imagen )
      .setTimestamp()
      await chImpl.send({embeds: [embedSugerencia]});
    } else {
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setTimestamp()
      await chImpl.send({embeds: [embedSugerencia]});
    }
    delete dbSugerenciasEscribir[idSugerencia];
    await escribirDatos(7);
    await interaction.reply("Sugerencia actualizada con éxito.")
  } else if(interaction.commandName === 'denegarsugerencia'){
    var idSugerencia = await interaction.options.getString('idsugerencia');
    if(!dbSugerenciasEscribir[idSugerencia]) return interaction.reply({content: 'La sugerencia no existe', ephemeral: true});
    const reason = await interaction.options.getString('reason');
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(canalSugerencias); 
    const msj = await ch.messages.fetch(idSugerencia);
    await msj.delete();
    const chDeneg =  await guildFetch.channels.resolve(sugDeneg);
    contenido = dbSugerenciasEscribir[idSugerencia].contenido;
    if(dbSugerenciasEscribir[idSugerencia].imagen != null){
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .addFields({name: 'Reason', value: '```' + reason + '```'})
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Red')
      .setImage(dbSugerenciasEscribir[idSugerencia].imagen )
      .setTimestamp()
      await chDeneg.send({embeds: [embedSugerencia]});
    } else {
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .addFields({name: 'Reason', value: '```' + reason + '```'})
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Red')
      .setTimestamp()
      await chDeneg.send({embeds: [embedSugerencia]});
    }
    delete dbSugerenciasEscribir[idSugerencia];
    await escribirDatos(7);
    await interaction.reply("Sugerencia actualizada con éxito.")
  } /* Información sobre otros bots */
  else if(interaction.commandName === 'musicbot'){
    var embedMusicBot = new EmbedBuilder()
    .setTitle('Información básica sobre el bot de música')
    .setAuthor({name: 'Jockie Music (1)#6951', iconURL: 'https://www.jockiemusic.com/assets/imgs/render.png'})
    .setThumbnail(interaction.guild.displayAvatarURL)
    .setColor('DarkGold')
    .setDescription('El bot solo funcionará en el canal de voz: <#1188501314892742757>')
    .addFields({name: '**m!play [cancion]**', value: 'Añades una canción a la lista de reproducción o empieza a sonar esa canción.'}, 
               {name: '**m!stop**', value: 'Paras la música y el bot abandona el canal de voz.'},
               {name: '**m!np**', value: 'Muestras información sobre la cancion que suena actualmente'},
               {name: '**m!queue**', value: 'Muestras la lista de reproducción del bot'})
    .setFooter({text: 'Esta no es información oficial, simplemente es un muy pequeño resumen.'})
    await interaction.reply({ephemeral: true, content: 'Ok'});
    await interaction.channel.send({embeds: [embedMusicBot]});

  } /*Comando say*/
  else if (interaction.commandName === 'say'){
    const contentSay = interaction.options.getString('content');
    await interaction.channel.send(contentSay);
    await interaction.reply({content: 'ok', ephemeral: true});
  } /*Eventos de discord crear */
  else if (interaction.commandName === 'crearevento'){
    const guildFetch = client.guilds.resolve(guildID);
      const titulo = interaction.options.getString('titulo');
      const descripcion = interaction.options.getString('descripcion');
      var ub = interaction.options.getString('location');
      ub = (ub == null) ? 'Escuela Técnica Superior de Ingenieros Informáticos de la Universidad Politécnica de Madrid' : ub;
      var fechaInicio = interaction.options.getString('fechainicio');
      var fechafin = interaction.options.getString('fechafin');
      var urlEvento;
      if(!verificarFecha(fechaInicio) || !verificarFecha(fechafin))
        return interaction.reply({content: 'Fechas en formato incorrecto, verifica que las fechas están en formato dd/m', ephemeral: true});
      arrFechaInicio = pasarAFecha(fechaInicio);
      arrFechaFin = pasarAFecha(fechafin);
      var fechaHoy = new Date();
      if (arrFechaInicio[1] < fechaHoy.getMonth() || (arrFechaInicio[1] === fechaHoy.getMonth() && arrFechaInicio[0] < fechaHoy.getDate())) {
        /* el evento es para el año que viene */
        fechaInicio = new Date(arrFechaInicio[1]+"/"+arrFechaInicio[0]+"/"+(fechaHoy.getFullYear()+1));
      } else {
        /*El evento es para este año */
        fechaInicio = new Date(arrFechaInicio[1]+"/"+arrFechaInicio[0]+"/"+(fechaHoy.getFullYear()));
      }
      if (arrFechaFin[1] < fechaHoy.getMonth() || (arrFechaFin[1] === fechaHoy.getMonth() && arrFechaFin[0] < fechaHoy.getDate())) {
        fechafin = new Date(arrFechaFin[1]+"/"+arrFechaFin[0]+"/"+(fechaHoy.getFullYear()+1));
      } else {
        fechafin = new Date(arrFechaFin[1]+"/"+arrFechaFin[0]+"/"+(fechaHoy.getFullYear()));
      }
      await guildFetch.scheduledEvents.create({
        name: titulo,
        description: descripcion,
        scheduledStartTime: fechaInicio,
        scheduledEndTime: fechafin,
        privacyLevel: 2,
        entityType: 3,
        entityMetadata: {
          location: ub,
        },
        reason: 'Creación de evento por parte de ' + interaction.member.id,
      });
    const ch = await interaction.guild.channels.resolve(canalEventos);
    const opciones = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    var embedNews = new EmbedBuilder()

    .setTitle('📣 **NUEVO EVENTO** 📣')
    .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL(), url: inviteServer})
    .setThumbnail(interaction.guild.iconURL())
    .setColor('DarkRed')
    .addFields({name: 'Nombre del evento: ', value: titulo},
               {name: 'Descripción del evento:', value: descripcion},
               {name: 'Fecha de inicio: ', value: ' ' + fechaInicio.toLocaleDateString(undefined, opciones)},
               {name: 'Fecha de finalización: ', value: ' ' + fechaInicio.toLocaleDateString(undefined, opciones)},
               {name: 'Ubicación: ', value: ub},
               {name: 'Invite del servidor de discord: ', value: `[Pulsa aquí](${inviteServer})`}
              )
    .setTimestamp()
    .setFooter({text: interaction.guild.name, iconURL: client.user.displayAvatarURL()})
    await ch.send({embeds: [embedNews]})
    interaction.reply('Todo ok');
        
  } /* Tempchannels */
  else if (interaction.commandName === 'creartempchannels'){
    const canal = interaction.options.getChannel('canal');
    if(canal.type != 2)
      return interaction.reply({content: 'Debes indicar un canal de voz', ephemeral: true});
    var cantidadUser = (interaction.options.getInteger('cantidaduser') == null) ? canal.userLimit : interaction.options.getInteger('cantidaduser');
    if(cantidadUser <0)
      return interaction.reply({content: 'Cantidad de usuarios incorrecta', ephemeral: true});
    cantidadUser = (cantidadUser >=100) ? 0: cantidadUser; /* Establecemos a infinito la cantidad de user factibles */
    /* Debemos establecer la base de datos.
      También debemos establecer por un booleano si este canal se puede borrar cuando está vació o no, en este caso no.
      La key sera el canal y tendrá min un atr de si es borrable
    */
    borrable = false;
    nombre = canal.name;
    dbTempchanelsEscribir[canal.id] = {borrable, cantidadUser, nombre};
    await escribirDatos(8);
    await interaction.reply('Canal establecido con éxito');
  } else if(interaction.commandName === 'enviarfaq'){
    // Imagen de bots auxiliares

    const canal = await interaction.options.getChannel('canal');
    const opcion = await interaction.options.getInteger('opcion');
      if(opcion == 1){
        var embedMusicBot = new EmbedBuilder()
        .setTitle('Información básica sobre el bot de música')
        .setAuthor({name: 'Jockie Music (1)#6951', iconURL: 'https://www.jockiemusic.com/assets/imgs/render.png'})
        .setThumbnail(interaction.guild.displayAvatarURL)
        .setColor('DarkGold')
        .setDescription('El bot solo funcionará en el canal de voz: <#1188501314892742757>')
        .addFields({name: '**m!play [cancion]**', value: 'Añades una canción a la lista de reproducción o empieza a sonar esa canción.'}, 
                  {name: '**m!stop**', value: 'Paras la música y el bot abandona el canal de voz.'},
                  {name: '**m!np**', value: 'Muestras información sobre la cancion que suena actualmente'},
                  {name: '**m!queue**', value: 'Muestras la lista de reproducción del bot'})
        .setFooter({text: 'Esta no es información oficial, simplemente es un muy pequeño resumen.'})
        await canal.send({embeds: [embedMusicBot]});
        // Imagen de tempchannel
        var embedTempchannels = new EmbedBuilder()
        .setTitle('Información sobre Tempchannel')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setColor('DarkGold')
        .setDescription('Todos los canales de voz pertenecientes a la categoría: <#1188827698987016252>, generan de manera automática un canal en la categoría: <#' + parentTempChannels + '>.\nCada canal genera uno nuevo para un número determinado de usuarios.')
        .setFooter({text: 'Club ping pong tempchannels', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedTempchannels]})
        //Imagen Sugerencias
        var embedSugerencias = new EmbedBuilder()
        .setTitle('Información sobre las sugerencias')
        .setColor('DarkGold')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription('Los parámetros obligatorios se denotan con **[]** y los opcionales con **()** ')
        .addFields({name: '**/sugerir [sugerencia] (adjunto)**', value: 'Envías una sugerencia.'})
        .setFooter({text: 'Sugerencias Club Ping Pong', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedSugerencias]});

        // Imagen de reservas 

        var embedReservas = new EmbedBuilder()
        .setTitle('Reserva de mesas')
        .setColor('DarkGold')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription('Los parámetros obligatorios se denotan con **[]** y los opcionales con **()** \nPuedes ver en tiempo real las reservas en este [google sheet](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)')
        .addFields({name: '**/reservamesa [dd/mm] [hh:mm] [hh:mm] (n_mesa)**', value: 'El primer parámetro es la fecha de la reserva, el segundo la hora de inicio, el tercero la hora de finalización y el cuarto, opcional, el número de la mesa.' },
                  {name: '**/mostrarreservas [dd/mm]**', value: 'Muestras las reservas en una determinada fecha, las puedes ver en tiempo real en este [google sheet](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)'},
                  {name: '**/cancelarreserva [dd/mm]**', value: 'Cancelas la reserva que tienes en una determinada fecha.'},
                  {name: 'Requisitos', value: 'Puedes reservar como máximo una fecha, con una antelación de 6 meses.'}      
                  )
        .setFooter({text: 'Reserva de mesas', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedReservas]});
        //Imagen torneos

        var embedTorneos = new EmbedBuilder()
        .setTitle('Participación en torneos')
        .setColor('DarkGold')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription('Hay dos modalidades de torneos:\n- Individual.\n- Parejas\nLos parámetros obligatorios se denotan con **[]** y los opcionales con **()**')
        .addFields({name: '**/torneo apuntarse individual [nombreTorneo] [correoinstitucional]**', value: 'Te apuntas a un torneo individual'},
                   {name: '**/torneo desapuntarse individual [nombreTorneo]**', value: 'Te desapuntas de un torneo individual'},
                   {name: '**/torneo apuntarse parejas [nombreTorneo] [correoinstitucional] (pareja) (correoparejainstitucional)**', value: 'Te apuntas a un torneo por parejas, en caso de no tener pareja, te intentaremos buscar una.\n- En caso de tener pareja, también debes proporcionar su correo institucional para inscribirte con él/ella.'},
                   {name: '**/torneo desapuntarse parejas [nombreTorneo]**', value: 'Te desapuntas solo a ti del torneo por parejas'}
        )
        .setFooter({text: 'Torneos', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedTorneos]});

      }else if (opcion == 2){
          var embedModmail = new EmbedBuilder()
          .setTitle('Opciones de comandos modmail')
          .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
          .setColor('DarkGold')
          .setThumbnail(interaction.guild.displayAvatarURL)
          .setDescription('Los **[]** son parámetros obligatorios y los **()** son parámetros opcionales\n[¿Cómo obtengo el id de un mensaje?](https://support.discord.com/hc/es/articles/206346498--D%C3%B3nde-puedo-encontrar-mi-ID-de-usuario-servidor-mensaje-)')
          .addFields({name: '**/reply [contenido] (adjunto)**', value: 'El contenido es el mensaje que recibe el user, el adjunto, opcional, es algo que quieres enviar al usuario, las imagenes enviadas no se pueden editar'},
                     {name: '**/editarmensajeticket [idMensaje] [nuevoContenido] **', value: 'Editas un mensaje que has enviado al usuario para ello necesitas la id del mensaje. '},
                     {name: '**/cerrarticket**', value: 'Cierras el ticket abierto de un usuario.'},
                     {name: '**/bloquearuser [usuario] [razón]**', value: 'Bloqueas a un usuario con su razon correspondiente.'},
                     {name: '**/desbloquearuser [user] **', value: 'Desbloqueas a un usuario del uso del bot.'},
                     {name: '**/sugerenciaimplementada [idSugerencia]**', value: 'Marcas como aprobada una sugerencia.'},
                     {name: '**/denegarsugerencia [idSugerencia] [razon]**', value: 'Deniegas una sugerencia con su correspondiente razón'},
                     {name: '**/crearevento [titulo] [descripcion] [fechainicio] [fechafin] (location)**', value: 'Creas un evento con un título determinado, con una descripcion, cono una fecha de inicio y fin, la localización por defecto es la facultad'},
                     {name: '**/establecerdbtorneo [tipo] [nombre]**', value: 'Creas un torneo, el tipo 0: Individual ripo:1 Parejas. \n Nombre es el nombre del torneo, por favor usar una única palabra como nombre del torneo a ser posible.'},
                     {name: '**/finalizarplazoinscripcion [nombre]**', value: 'Finalizas el plazo de inscripción para el torneo con un nombre determinado.'}
                    )
          .setFooter({text: 'Modmail Club Ping Pong', iconURL: interaction.guild.iconURL()})
          await canal.send({embeds: [embedModmail]});
      }
      await interaction.reply('Ok');
  } /*reglas */
  else if(interaction.commandName  === 'reglas'){
    const ch = await interaction.options.getChannel('channel');
    if(ch.type != 0) return interaction.reply({content: 'No es un canal de texto', ephemeral: true});
    try{
      await ch.createWebhook({
        name: 'Reglas Club Ping Pong',
        avatar: client.user.displayAvatarURL(),
        reason: 'Webhook de reglas del servidor'
      }).then(async webhook =>{
        await webhook.send('Bienvenido/a al servidor de Discord del club de tenis de mesa de la facultad. Este es un lugar para hablar sobre el tenis de mesa , compartir consejos, organizar partidas y hacer amigos. Para que todos podamos disfrutar de este espacio, te pedimos que sigas estas normas:\n\n- Sé respetuoso/a con los demás miembros. No insultes, amenaces, acoses o discrimines a nadie por su género, orientación sexual, raza, religión, edad, nacionalidad o nivel de juego.\n- No compartas contenido ilegal, violento, pornográfico, ofensivo o que incite al odio. Tampoco hagas spam, publicidad o autopromoción sin permiso de los administradores.\n- Usa los canales adecuados para cada tema. No desvíes la conversación ni interrumpas a los demás. Si quieres hablar de algo que no está relacionado con el tenis de mesa, usa el canal <#1190035656408313927>.\n- La normativa oficial del tenis de mesa lo puedes encontrar en <#1190311360563773480>, si tienes alguna duda con respecto a las mismas puedes hacérnosla saber en <#1190313214026711130>.\n- Respeta las decisiones de los administradores y moderadores. Ellos están para mantener el orden y la armonía en el servidor. Si tienes alguna duda o queja, puedes contactar con ellos por mensaje privado al bot del club .\n- Si tienes alguna sugerencia no dudes en hacerla con **/sugerir**.\n- Diviértete y disfruta del tenis de mesa. Recuerda que este es un espacio para compartir nuestra afición, aprender unos de otros y pasar un buen rato.\n\nEl incumplimiento de estas normas puede resultar en una advertencia, una expulsión temporal o permanente del servidor, según la gravedad de la falta.\nGracias por tu colaboración y esperamos que te lo pases bien en nuestro servidor.\n\nInvite del servidor: \n' + inviteServer);
        await webhook.delete();
      });
      await interaction.reply('Ok');
    }catch (error){
      interaction.reply("Error: \n" + error);
    }
  } /* Reglamento */
  else if(interaction.commandName === 'reglamentoindividual'){
    const ch = await interaction.options.getChannel('channel');
    if(ch.type != 0) return interaction.reply({content: 'No es un canal de texto', ephemeral: true});
    try{
      await ch.createWebhook({
        name: 'Reglamento Individual',
        avatar: client.user.displayAvatarURL(),
        reason: 'Webhook de reglas del servidor'
      }).then(async webhook =>{
        await webhook.send('***REGLAMENTO OFICIAL PING PONG INDIVIDUAL***');
        await webhook.send('**SERVICIO**:\n- Se comenzará con la pelota sobre la palma, de manera que sea claramente visible.\n- A la hora de sacar, se deberá lanzar la pelota como mínimo 16 cm verticalmente, para luego, cuando descienda golpearla. En individual no es necesario sacar en diagonal, la pelota podrá aterrizar en cualquier lado del otro campo. El saque deberá realizarse por encima de la altura de la mesa, y detrás de ella.\n\n- Si al realizar un servicio correcto, la pelota toca la red y luego bota en el campo enemigo, se deberá repetir el saque. No es media, como en el tenis, sólo se tendrá un intento más (a menos que se vuelva a tocar la red).\n- Además, si se realiza un servicio sin que el otro jugador esté preparado, también se repetirá sin que nadie anote punto.');
        await webhook.send('**REPARTO DEL SERVICIO**:\n- El derecho a elegir el orden inicial de servir, recibir o lado de la mesa será decidido por sorteo, y el ganador puede elegir servir o recibir primero, o empezar en un determinado lado de la mesa.\n- Cuando un jugador ha elegido servir o recibir primero, o empezar en un lado determinado, el otro jugador o pareja tendrá la otra elección.\n- Después de cada 2 tantos anotados, el receptor o pareja receptora pasará a ser el servidor o pareja servidora, y así hasta el final del juego, a menos que ambos jugadores hayan anotado 10 tantos. En estos últimos casos, el orden del servicio y de la recepción será el mismo, pero cada jugador servirá tan sólo un tanto alternativamente.');
        await webhook.send('**DEVOLUCIÓN**:\n- Tras el servicio se jugará de manera normal, devolviendo la pelota siempre después de que bote en tu campo.');
        await webhook.send('**TANTOS**:\nUn jugador anotará un tanto:\n- Si un oponente no hace un servicio correcto. \n- Si un oponente no hace una devolución correcta.\n- Sí, tras haber realizado un servicio o una devolución, la pelota toca cualquier cosa, excepto el conjunto de la red, antes de ser golpeada por un oponente.\n- Si la pelota pasa por encima de su campo o más allá de su línea de fondo sin haber tocado su campo, tras ser golpeada por un oponente.\n- Si la pelota, después de haber sido golpeada por un oponente, pasa a través de la red, o entre la red y los postes de ésta, o entre la red y la superficie de juego.\n- Si un oponente obstruye la pelota.\n- Si un oponente golpea la pelota dos veces consecutivas de forma deliberada.\n- Si un oponente golpea la pelota con un lado de la hoja de la raqueta cuya superficie no cumple los requisitos exigidos.\n- Si un oponente, o cualquier cosa que éste vista o lleve, mueve la superficie de juego.\n- Si un oponente, o cualquier cosa que éste vista o lleve, toca el conjunto de la red.\n- Su oponente toca la mesa con cualquier mano antes de golpear la pelota.\n- El reposapiés o los pies del oponente tocan el suelo durante el juego.\n- Si se comete alguna infracción del reglamento.' );
        await webhook.send('**GANAR UN SET**:\n- Ganará un set el jugador que primero alcance 11 tantos, excepto cuando ambos jugadores consigan 10 tantos; en este caso, ganará el juego el primer jugador o pareja que posteriormente obtenga 2 tantos de diferencia.');
        await webhook.send('**FAIR PLAY**:\n- Los jugadores y entrenadores u otros consejeros evitarán comportamientos que puedan afectar injustamente a su oponente, ofender a los espectadores o desacreditar el deporte, como, por ejemplo, lenguaje inapropiado, romper deliberadamente la pelota o golpearla hacia fuera del área de juego, dar patadas a la mesa o a las vallas y faltar al respeto a los oficiales de partidos.\n- Si se observa este comportamiento en algún jugador de manera repetida será descalificado del torneo.');
        await webhook.send('**¿Quieres más información?**\n- Puedes consultarla [aquí](https://www.upm.es/sfs/Rectorado/Vicerrectorado%20de%20Alumnos/Deportes/Reglamento%20de%20Tenis%20de%20Mesa%2022-23.pdf).')
        await webhook.delete();
      });
      await interaction.reply('Ok');
    }catch (error){
      interaction.reply("Error: \n" + error);
    }
  } /*Torneo^^ */
  else if (interaction.commandName === 'torneo'){
    if(interaction.options.getSubcommandGroup() === 'apuntarse'){
      if(interaction.options.getSubcommand() === 'individual'){
        const nomTorneo = interaction.options.getString('nombre');
        const correo = interaction.options.getString('correo');
        if(verificarCorreoInstitucional(correo))
          return interaction.reply({content: 'Debe ser tu correo institucional', ephemeral: true});
        if(!dbTorneosParticipandoEscribir[nomTorneo])
          return interaction.reply({content: 'No existe el torneo', ephemeral: true});
        if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)!= -1)
          return interaction.reply({content: 'Ya estás inscrito', ephemeral: true});
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          if(!sheet)
            return interaction.reply('Ese torneo no existe');
          const reservaSheet = await sheet.addRows([
          { User: `${interaction.member.displayName}`, UserId: interaction.member.id, Correo: correo }/* Datos salvados de los usuarios inscritos */
          ]);
          dbTorneosParticipandoEscribir[nomTorneo].participantes = anadirDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, interaction.member.id, dbTorneosParticipandoEscribir[nomTorneo].participantes.length);
          await escribirDatos(9);
        }catch(error){
          console.log(error)
          interaction.reply({content: 'Se ha producido un error con la inscripción.', ephemeral: true});
        }
        try{
          var embedTorneoApuntadoIndividual = new EmbedBuilder()
          .setTitle('**Inscripción en torneo individual**')
          .setColor('DarkGreen')
          .setThumbnail(interaction.guild.iconURL())
          .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
          .setDescription('Ha sido inscrito en el torneo individual de manera satisfactoria. \n- Torneo: ' + nomTorneo)
          .setTimestamp()
          await interaction.member.send({embeds: [embedTorneoApuntadoIndividual]});
        } catch( error){
          /* La única de las opciones es que el usuario no admita md del bot */
          var embedTorneoApuntadoIndividual = new EmbedBuilder()
          .setTitle('**Inscripción en torneo individual**')
          .setColor('DarkGreen')
          .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
          .setDescription('Ha sido inscrito en el torneo individual de manera satisfactoria. \n- Torneo: ' + nomTorneo)
          .setTimestamp()
          await interaction.channel.send({embeds: [embedTorneoApuntadoIndividual]});
        }
        interaction.reply({content: 'Operación realizada con éxito.', ephemeral: true});
      } else if(interaction.options.getSubcommand() === 'parejas'){
        const nomTorneo = interaction.options.getString('nombre');
        const pareja = interaction.options.getUser('companero');
        const correo = interaction.options.getString('correo');
        const correoCompanero = interaction.options.getString('correocompanero');
        if(pareja!=null && correoCompanero == null)
          await interaction.reply({content: 'Debes introducir el correo institucional de tu compañero', ephemeral: true})
        if(pareja.bot)
          return interaction.reply({content: 'No puedes jugar con un bot', ephemeral: true});
        if(!dbTorneosParticipandoEscribir[nomTorneo])
          return interaction.reply({content: 'No existe el torneo', ephemeral: true});
        if(verificarCorreoInstitucional(correo))
          return interaction.reply({content: 'Debes introducir un correo institucional.', ephemeral: true});
        if(pareja != null && correoCompanero != null){
          if(verificarCorreoInstitucional(correoCompanero))
            return interaction.reply({content: 'Debes introducir un correo institucional.', ephemeral: true});
        }
        if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)!= -1)
          return interaction.reply({content: 'Ya estás inscrito', ephemeral: true});
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          if(!sheet)
            return interaction.reply({content: 'Ese torneo no existe', ephemeral: true});
          const reservaSheet = await sheet.addRows([
          { User: `${interaction.member.displayName}`, Correo: correo , UserId: interaction.member.id, Companero: (pareja!=null)? pareja.displayName : '', CompaneroId: (pareja != null)? pareja.id:'', CorreoCompanero: (pareja!=null) ? correoCompanero: '' }/* Datos salvados de los usuarios inscritos */
          ]);
          dbTorneosParticipandoEscribir[nomTorneo].participantes = anadirDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, interaction.member.id, dbTorneosParticipandoEscribir[nomTorneo].participantes.length);
          await escribirDatos(9); 
          if(pareja!=null){
            dbTorneosParticipandoEscribir[nomTorneo].participantes = anadirDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, pareja.id, dbTorneosParticipandoEscribir[nomTorneo].participantes.length);
            await escribirDatos(9);
          }
          interaction.reply({content: 'Proceso realizado con éxito', ephemeral: true});   
          try{
            var embedInscrPar = new EmbedBuilder()
            .setTitle('**Inscripción torneo en parejas**')
            .setColor('DarkGreen')
            .setDescription('Inscripción satisfactoria en el torneo.\n- Comando ejecutado por: ' + interaction.member.displayName + '\n- Inscripción en: ' + nomTorneo)
            .setThumbnail(interaction.guild.iconURL())
            .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
            .setTimestamp()
            await interaction.member.send({embeds: [embedInscrPar]});
            if(pareja !=null){
              await pareja.send({embeds: [embedInscrPar]});
            }
          } catch(error){
            var embedInscrPar = new EmbedBuilder()
            .setTitle('**Inscripción torneo en parejas**')
            .setColor('DarkGreen')
            .setDescription('Inscripción satisfactoria en el torneo.\n- Comando ejecutado por: ' + interaction.member.displayName + '\n- Inscripción en: ' + nomTorneo)
            .setThumbnail(interaction.guild.iconURL())
            .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
            .setTimestamp()
            if(pareja!=null){
              await interaction.channel.send({content: `<@${pareja.id}>`, embeds: [embedInscrPar]});
            } else {
              await interaction.channel.send({embeds: [embedInscrPar]})
            }
          }
        
          
        }catch(error){
          console.log(error)
          interaction.reply({content: 'Se ha producido un error con la inscripción.', ephemeral: true});
        }
      }
    } else  if(interaction.options.getSubcommandGroup() === 'desapuntarse'){  
      if(interaction.options.getSubcommand() === 'individual'){
        const nomTorneo = interaction.options.getString('nombre');
        if(!dbTorneosParticipandoEscribir[nomTorneo])
          return interaction.reply('No existe el torneo');
        if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)== -1)
          return interaction.reply('No estas inscrito');
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        if(!sheet)
          return interaction.reply('Ese torneo no existe');
        const userBorrar = interaction.member.id;
        /* Vamos a intentar borrar por nombre. */
        await sheet.loadCells();
        // Encontrar y eliminar la fila
        const rows = sheet.rowCount;
        continuar = true;
        for (let i = 0; i < rows && continuar; i++) {
          const cell2 = sheet.getCell(i, 1)
          if (cell2.value == userBorrar) {
            sheet.clearRows({start: i+1, end: i+1});
            continuar = false;
          }
        } 
        dbTorneosParticipandoEscribir[nomTorneo].participantes = eliminarDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id), dbTorneosParticipandoEscribir[nomTorneo].participantes.length )
        await escribirDatos(9);
        interaction.reply('Operación realizada con éxito.');
      } else if(interaction.options.getSubcommand() === 'parejas') {
          const nomTorneo = interaction.options.getString('nombre');
          if(!dbTorneosParticipandoEscribir[nomTorneo])
            return interaction.reply('No existe el torneo');
          if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)== -1)
            return interaction.reply('No estas inscrito');
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          if(!sheet)
            return interaction.reply('Ese torneo no existe');
          const userBorrar = interaction.member.id;
          /* Vamos a intentar borrar por nombre. */
          await sheet.loadCells();
          // Encontrar y eliminar la fila
          const rows = sheet.rowCount;
          continuar = true;
          for (let i = 0; i < rows && continuar; i++) {
            const cellBuscandoOp1 = sheet.getCell(i, 1);
            const cellBuscandoOp2 = sheet.getCell(i, 4);
            if (cellBuscandoOp1.value == userBorrar) {
              console.log('Encontrado y esta persona hizo el comando');
              /* El que ejecutó la inscripción se va */
              cellBuscandoOp1.value='';
              var cell1 = sheet.getCell(i, 0);
              var cell2 = sheet.getCell(i,2);
              cell1.value='';
              cellBuscandoOp1.save();
              cell1.save();
              cell2.value='';
              cell2.save();
              continuar = false;
            } else if (cellBuscandoOp2.value == userBorrar){
              console.log('Encontrado e hizo otra persona el comando');
              cellBuscandoOp2.value='';
              var cell1 = sheet.getCell(i,3);
              var cell2 = sheet.getCell(i,5);
              cell2.value='';
              cell2.save();
              cell1.value='';
              cellBuscandoOp2.save();
              cell1.save();
              continuar = false;
            }
          } 
          dbTorneosParticipandoEscribir[nomTorneo].participantes = eliminarDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id), dbTorneosParticipandoEscribir[nomTorneo].participantes.length )
          await escribirDatos(9);
          interaction.reply({content: 'Operación realizada con éxito.', ephemeral: true});
      }
    }
    
  } else if(interaction.commandName === 'establecerdbtorneo'){
    const tipo = interaction.options.getInteger('tipo');
    const nombre = interaction.options.getString('nombre');
    if(tipo === 0){
      const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
      const sheet = await doc.addSheet({ headerValues: ['User', 'UserId', 'Correo'] });
      await sheet.updateProperties({ title: nombre });
      await interaction.reply('Creado con exito');
      var participantes = new Array(0);
      dbTorneosParticipandoEscribir[nombre] = {participantes};
      await escribirDatos(9);
    } else if(tipo === 1){
      const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
      const sheet = await doc.addSheet({ headerValues: ['User', 'UserId','Correo', 'Companero', 'CompaneroId','CorreoCompanero'] });
      await sheet.updateProperties({ title: nombre });
      await interaction.reply('Creado con exito');
      var participantes = new Array(0);
      dbTorneosParticipandoEscribir[nombre] = {participantes};
      await escribirDatos(9);
    } else {
      interaction.reply('Opción no contemplada, cancelado.');
    }
  } else if (interaction.commandName === 'finalizarplazoinscripcion'){
    const torneo = await interaction.options.getString('nombre');
    if(!dbTorneosParticipandoEscribir[torneo])
      return interaction.reply('El torneo no existe o ya fue finalizado el plazo de inscripción');
    delete dbTorneosParticipandoEscribir[torneo];
    await escribirDatos(9);
    interaction.reply('Plazo de inscripción finalizado con éxito para:\n- ' + torneo);
  }
  const guildFetch = client.guilds.resolve(guildID);
  const channelLogsSlash = guildFetch.channels.resolve(logComandos);
  var embedLogSlash =  new EmbedBuilder()
  .setTitle(`Nueva ejecución de comando`)
  .addFields({name: 'User', value: `${interaction.member.displayName} -> (${interaction.member.id})`},
             {name: `Comando:`, value: `${interaction.commandName}`}
            )
  .setColor('Default')
  .setTimestamp()
  await channelLogsSlash.send({embeds: [embedLogSlash]})

});

/*Modmail edición de mensajes */

client.on('messageUpdate', async(oldMessage, newMessage)=>{
  try{
    if(oldMessage.partial) await oldMessage.fetch();
    if(newMessage.partial) await newMessage.fetch();
    if(!newMessage.author.bot &&!oldMessage.guild && dbUseraServerEscribir[newMessage.author.id].mensajesEnUser.indexOf(oldMessage.id)!= -1){
      /* Se debe cambiar  un mensaje de la database */
      const guild = await client.guilds.resolve(guildID);
      
      const channelGuild = await guild.channels.fetch(dbUseraServerEscribir[newMessage.author.id].idChannel);
      var pos = dbUseraServerEscribir[newMessage.author.id].mensajesEnUser.indexOf(newMessage.id);
      var arr = dbUseraServerEscribir[newMessage.author.id].mensajesEnServer;
      await channelGuild.messages.fetch(arr[pos]).then(async msg =>{
        await msg.edit(`**Mensaje editado**:\n${newMessage.content}\n**Mensaje anterior editado**: (Puede haber más verificar logs)\n${oldMessage.content}`);
      });
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedChange = new EmbedBuilder()
      .setTitle(`Mensaje en Modmail editado por parte del usuario`)
      .addFields({name: 'User', value:`${newMessage.author.displayName} -> (${newMessage.author.id})`},
                 {name: 'Contenido anterior: (Puede ser null si el bot se apago y perdió el caché)', value: `${oldMessage.content}`},
                 {name: 'Nuevo contenido:', value: `${newMessage.content}`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedChange]});
    }
  }catch(error){
    console.log(error);
  }
});

/* Modmail se borran mensajes. */
client.on('messageDelete', async message=>{
  try{
    if(message.partial) await message.fetch();
    if( !message.guild && dbUseraServerEscribir[message.author.id].mensajesEnUser.indexOf(message.id)!= -1){
      /* Se borra un mensaje que está asociado en la database */
      const guild = await client.guilds.resolve(guildID);
      const channelGuild = await guild.channels.fetch(dbUseraServerEscribir[message.author.id].idChannel);
      var pos = dbUseraServerEscribir[message.author.id].mensajesEnUser.indexOf(message.id);
      var arr = dbUseraServerEscribir[message.author.id].mensajesEnServer;
      await channelGuild.messages.fetch(arr[pos]).then(async msg =>{
        await msg.edit(`**Mensaje borrado:**\n${message.content}`);
      });
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedDelete = new EmbedBuilder()
      .setTitle(`Mensaje en Modmail borrado por parte del usuario`)
      .addFields({name: 'User', value:`${message.author.displayName} -> (${message.author.id})`},
                 {name: 'Contenido:', value: `${message.content}`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedDelete]});
    } 
  }catch(error){
    console.log(error);
  }
});


/*  Reactions */

client.on('messageReactionAdd', async(messageReaction, user)=>{
  try{
    if (user.partial) await user.fetch();
    if(user.bot) return;
    if(messageReaction.partial) await messageReaction.fetch(); 
    var reactionID = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id; 
      if(dbReactionRoleEscribir[messageReaction.message.id]){
        if(dbReactionRoleEscribir[messageReaction.message.id].canalID == messageReaction.message.channel.id && (dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)!=-1)){
          /* La reacción está en la database */
          const member = await messageReaction.message.guild.members.fetch(user.id);
          // Asignamos el role por id.
          await member.roles.add(dbReactionRoleEscribir[messageReaction.message.id].role[dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)]);
        }
    } else if (!messageReaction.message.guild && dbUseraServerEscribir[user.id]) {
      try{
        const guild = await client.guilds.resolve(guildID);
        const channel = await guild.channels.resolve(dbUseraServerEscribir[user.id].idChannel);
        var pos = dbUseraServerEscribir[user.id].mensajesEnUser.indexOf(messageReaction.message.id);
        var mensajeIDServer = dbUseraServerEscribir[user.id].mensajesEnServer;
        const mensaje = await channel.messages.fetch(mensajeIDServer[pos]);
        await mensaje.react(messageReaction.emoji);
      }catch(error){
        console.log(error);
      }

    } else if(messageReaction.message.guild && dbServeraUserEscribir[messageReaction.message.channel.id]){
      const user = await client.users.fetch(dbServeraUserEscribir[messageReaction.message.channel.id].idUser);
      var pos = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnServer.indexOf(messageReaction.message.id);
      console.log(pos);
      var arr = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnUser;
      const mensaje = await user.dmChannel.messages.fetch(arr[pos]);
      await mensaje.react(messageReaction.emoji);
    }/* Reacciones para sugerencias */
    else if(dbSugerenciasEscribir[messageReaction.message.id]){
      /* Significa que el mensaje está en la base de datos de sugerencias */
      // Debo sacar la cantidad de reacciones por tipo de reacciones, suponiendo que solo va a  haber tres.
      //console.log(messageReaction.message.reactions.resolve('✅').count)
      var contadorOk = messageReaction.message.reactions.resolve('✅').count -1;
      var contadorIdk = messageReaction.message.reactions.resolve('🫥').count -1;
      var contadorX = messageReaction.message.reactions.resolve('❌').count -1;
      var contadorVotacionesTotales = (contadorOk+contadorIdk+contadorX);
      const mensaje = messageReaction.message;
      const user = client.users.resolve(dbSugerenciasEscribir[mensaje.id].user);
      if(dbSugerenciasEscribir[mensaje.id].imagen != null){
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setImage(dbSugerenciasEscribir[mensaje.id].imagen)
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]})
      } else {
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]});
      }
    }
  } catch(error){
    console.log(error);
  }
});


client.on('messageReactionRemove', async(messageReaction, user)=>{
  try{
    if (user.partial) await user.fetch();
    if(user.bot) return;
    if(messageReaction.partial) await messageReaction.fetch(); 
    var reactionID = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id; 
    if(dbReactionRoleEscribir[messageReaction.message.id]){
      if(dbReactionRoleEscribir[messageReaction.message.id] && dbReactionRoleEscribir[messageReaction.message.id].canalID == messageReaction.message.channel.id && (dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)!=-1)){
        /* La reacción está en la database */
        const member = await messageReaction.message.guild.members.fetch(user.id);
        // Asignamos el role por id.
        await member.
        roles.remove(dbReactionRoleEscribir[messageReaction.message.id].role[dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)]   );
      }
    }  else if (!messageReaction.message.guild && dbUseraServerEscribir[user.id]) {
      try{
        const guild = await client.guilds.resolve(guildID);
        const channel = await guild.channels.resolve(dbUseraServerEscribir[user.id].idChannel);
        var pos = dbUseraServerEscribir[user.id].mensajesEnUser.indexOf(messageReaction.message.id);
        var mensajeIDServer = dbUseraServerEscribir[user.id].mensajesEnServer;
        const mensaje = await channel.messages.fetch(mensajeIDServer[pos]);
        var aBuscar = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id;
        await mensaje.reactions.resolve(aBuscar).remove();
      }catch(error){
        console.log(error);
      }

    }  else if(messageReaction.message.guild && dbServeraUserEscribir[messageReaction.message.channel.id]){
      // Da error falta por implementar
      const user = await client.users.fetch(dbServeraUserEscribir[messageReaction.message.channel.id].idUser);
      var pos = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnServer.indexOf(messageReaction.message.id);
      var arr = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnUser;
      const mensaje = await user.dmChannel.messages.fetch(arr[pos]);
      var aBuscar = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id;
      await mensaje.reactions.resolve(aBuscar).remove(client.user);
    }/* Reacciones para sugerencias */
    else if(dbSugerenciasEscribir[messageReaction.message.id]){
      /* Significa que el mensaje está en la base de datos de sugerencias */
      // Debo sacar la cantidad de reacciones por tipo de reacciones, suponiendo que solo va a  haber tres.
      //console.log(messageReaction.message.reactions.resolve('✅').count)
      
      var contadorOk = messageReaction.message.reactions.resolve('✅').count -1;
      var contadorIdk = messageReaction.message.reactions.resolve('🫥').count -1;
      var contadorX = messageReaction.message.reactions.resolve('❌').count -1;
      contadorVotacionesTotales = (contadorOk + contadorIdk + contadorX);
      const mensaje = messageReaction.message;
      const user = client.users.resolve(dbSugerenciasEscribir[mensaje.id].user);
      if(dbSugerenciasEscribir[mensaje.id].imagen != null){
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setImage(dbSugerenciasEscribir[mensaje.id].imagen)
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]})
      } else {
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]});
      }
    }
  } catch(error){
    console.log(error);
  }
});

/* Modmail */
client.on("messageCreate", async message => {

    try{
    if(message.partial)
      await message.fetch();
    if(message.author.bot && message.channel.type === 5 && message.channel.id === canalEventos){
      message.crosspost()
    }
    if(message.author.bot) return; 
    if(!message.guild && bloqueadosModmailEscribir[message.author.id])
      return message.reply('🔒 Está bloqueado del modmail')
    if(!message.guild){
      /* Caso del md para el modmail */
      const guild = await client.guilds.resolve(guildID);
      if(dbUseraServerEscribir[message.author.id]){
        /*Caso en el cual el usuario ya tiene un ticket de modmail abierto. */
        const ch = await guild.channels.resolve(dbUseraServerEscribir[message.author.id].idChannel);
        await ch.send(`**${message.author.displayName}**: \n<@&${idRoleSoporte}>`);
        var mensajeEnServer = await ch.send(message.content + "ㅤ");
        var mensajeEnUsuario = message.id;
        if(message.attachments.size>0){
          message.attachments.forEach(async at=>{
            await ch.send(at.url);
          });
        }
        dbUseraServerEscribir[message.author.id].mensajesEnUser = anadirDelArray(dbUseraServerEscribir[message.author.id].mensajesEnUser, message.id, dbUseraServerEscribir[message.author.id].longitud);
        dbUseraServerEscribir[message.author.id].mensajesEnServer = anadirDelArray(dbUseraServerEscribir[message.author.id].mensajesEnServer, mensajeEnServer.id, dbUseraServerEscribir[message.author.id].longitud);
        dbUseraServerEscribir[message.author.id].longitud = dbUseraServerEscribir[message.author.id].longitud +1;
        dbServeraUserEscribir[ch.id].mensajesEnUser= dbUseraServerEscribir[message.author.id].mensajesEnUser;
        dbServeraUserEscribir[ch.id].mensajesEnServer = dbUseraServerEscribir[message.author.id].mensajesEnServer;
        dbServeraUserEscribir[ch.id].longitud = dbUseraServerEscribir[message.author.id].longitud;
        await escribirDatos(3);
        await escribirDatos(4);
        await message.react('✅');
        await ch.setTopic(`Ticket pendiente de la respuesta del staff. \n Última interaccion ${new Date()}`);
      } else {
        const embedNuevoTicket = new EmbedBuilder()
        .setTitle('¿Quieres crear un ticket?')
        .setAuthor({name: client.user.displayName, avatarURL: client.user.displayAvatarURL})
        .setDescription('Un ticket es para hacer consultas a los moderadores y administridores del servidor.\nSi quieres ponerte en contacto reacciona con el emoji de a continuación. \nSi no ignora este mensaje.')
        .setColor('Yellow')
        .setTimestamp()
        await message.channel.send({embeds: [embedNuevoTicket]}).then(async msg =>{
          emoji = await client.emojis.resolveId(emojiAperturaTicket);
          await msg.react(emoji);
          const filter = (reaction, user) => {
            user.id === message.author.id && msg.id === reaction.message.id;
          };
          var salvado = false; // Salvaguarda para solo guardar un emoji por comando.
          const Collector = msg.createReactionCollector(filter, { time: 120000, max: 1 });
          Collector.on('collect', async reaction => {
            if(salvado) return;
            if(reaction.emoji.id == emojiAperturaTicket || reaction.emoji.name == emojiAperturaTicket){/*Depende del caso de que sea un emoji estándar o de un server */
              /* Debemos añadir a la correspondiente database y crear un canal de texto en la categoria del servidor correspondiente. */
              await guild.channels.create({name: `ticket-${message.author.displayName}`, parent: categoriaTicketsID, topic: `Ticket pendiente de la respuesta del staff. \n Última interaccion ${new Date()}`}).then(async ch =>{
                //Establecemos los datos en la database.
                var idChannel = ch.id;
                var idUser = message.author.id;
                var mensajesEnUser = [message.id];
                var longitud = 1;
                await ch.send(`**${message.author.displayName}**: \n<@&${idRoleSoporte}>`);
                var primMsgServer = await ch.send(message.content + "ㅤ");/* Le metemos un caracter invisible para evitar posibles errores de que solo haya un archivo. */
                var mensajesEnServer = [primMsgServer.id];
                dbUseraServerEscribir[message.author.id] = {idChannel, mensajesEnUser, mensajesEnServer, longitud};
                dbServeraUserEscribir[ch.id] = {idUser, mensajesEnUser, mensajesEnServer, longitud};
                await escribirDatos(3);
                await escribirDatos(4);
                if(message.attachments.size>0){
                  message.attachments.forEach(async at=>{
                    await ch.send(at.url);
                  });
                }
              });
              salvado = true;
              try{
                const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
                await doc.loadInfo();
                const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
                const reservaSheet = await sheet.addRows([
                  { Fecha: new Date(), Staff: ` `, Accion: `Contacto por modmail de parte de ${message.author.displayName}-> (${message.author.id})`, Reason: message.content}
                ]);
              }catch(error){
                console.log(error)
              }
            }
          });
        });


      }
    }
  }catch(error){
    console.log(error);
  }
});


/*Entra un nuevo miembro al servidor */
client.on('guildMemberAdd', async (member) =>{
  const guild = await client.guilds.resolve(guildID);
  const channelWelcome = await guild.channels.resolve(canalBienvenida);
});



/* TEMPCHANNELS */
client.on("voiceStateUpdate", async (oldState, newState) => {
  if(newState.channel != null && dbTempchanelsEscribir[newState.channel.id] && dbTempchanelsEscribir[newState.channel.id].borrable == false){
    /*Significa que es un canal el que crea tempchannel*/
    /* Debemos crear un canal de voz en un parent determinado y mover al usuario creador a su canal. */
    newState.guild.channels.create({name: `${dbTempchanelsEscribir[newState.channel.id].nombre}-${newState.member.displayName}`, parent: parentTempChannels, type: 2}).then(async ch =>{
      await ch.setUserLimit(dbTempchanelsEscribir[newState.channel.id].cantidadUser); /* Establecemos el límite de usuarios del canal */
      await newState.setChannel(ch); /*Desplazamos al usuario al canal oportuno */
      borrable = true;
      creador = newState.member.id;
      dbTempchanelsEscribir[ch.id] = {borrable, creador}; /*No necesito salvar más datos que estos para saber que el canal se puede borrar.*/
      await escribirDatos(8);
    });
  } else if (oldState .channel!= undefined && dbTempchanelsEscribir[oldState.channel.id] && oldState.channel.members.size === 0 && dbTempchanelsEscribir[oldState.channel.id].borrable == true){
    /*Significa que debemos de borrar el canal*/
    var canal = oldState.channel.id;
    await oldState.channel.delete("Canal tempchannel de: " + dbTempchanelsEscribir[oldState.channel.id].creador);
    delete dbTempchanelsEscribir[canal];
    await escribirDatos(8);
  }

});



















// Log in to Discord with your client's token
client.login(token);





/*Clases auxiliares y funciones auxiliares para almacenamiento de datos en base de datos*/

function buscarMesa(horaInicio, horaFin, db){
  continuar = true;
  let i = 1;
  while(i <= numMesas && continuar){
    continuar = (verificarMesa(i, horaInicio, horaFin, db) == -1);
    i = i+1;
  }
  return (continuar == false) ? (i-1):-1;
}
function verificarMesa(mesa, horaInicio, horaFin, db){
  arrHorasInicio = db.arrayHoraInicio;
  arrHorasFin = db.arrayHoraFin;
  arrMesas = db.arrayMesas;
  disponible = true;
  /*De precondición todos los arrays deben tener la misma longitud*/

  // Iterar sobre las reservas existentes en la misma fecha
  for (let i = 0; i < db.longitud && disponible; i++) {
    if ((seSolapan(horaInicio, horaFin, arrHorasInicio[i], arrHorasFin[i])) && mesa === arrMesas[i]) {
      /*Implica que hay solapamiento y las mesas que verificamos que son la misma mesa. */
      disponible = false;
    }
  }
  return (disponible == false) ? -1: mesa;
}
function escribirDatos(db){
  if(db === 1){
    fs.writeFile("./databases/reservas.json", JSON.stringify(dbReservasEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db === 2){
    fs.writeFile("./databases/reactionrole.json", JSON.stringify(dbReactionRoleEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db === 3){
    fs.writeFile("./databases/serverauser.json", JSON.stringify(dbServeraUserEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 4){
    fs.writeFile("./databases/useraserver.json", JSON.stringify(dbUseraServerEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 5){
    fs.writeFile("./databases/bloqueadosmodmail.json", JSON.stringify(bloqueadosModmailEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db ==6){
    fs.writeFile("./databases/reservashechasporuser.json", JSON.stringify(dbReservasHechasPorUserEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 7){
    fs.writeFile("./databases/sugerencias.json", JSON.stringify(dbSugerenciasEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 8){
    fs.writeFile("./databases/tempchannels.json", JSON.stringify(dbTempchanelsEscribir, null, " "), function(err){
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 9){
    fs.writeFile("./databases/torneosparticipando.json", JSON.stringify(dbTorneosParticipandoEscribir, null, " "), function(err){
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  }
}
function anadirDelArray(arrayOriginal, nuevoDato, longitudArray){
  arrayRes = new Array(longitudArray +1);
  let i = 0;
  while(i < longitudArray){
    arrayRes[i] = arrayOriginal[i];
    i = i+1;
  }
  arrayRes[longitudArray] = nuevoDato;
  return arrayRes;
}
function eliminarDelArray(arrayOriginal, pos, longitudArray){
  arrayRes = new Array(longitudArray-1);
  j = 0;
  for(i = 0; i < longitudArray; i++){
    if(i!=pos){
      arrayRes[j] = arrayOriginal[i];
      j++; 
    }
  }
  return arrayRes;
}
function verificarHoras(hora){
  /* Hacemos un try catch ya que pueden meter un caracter que no puede hacerse un parseInt */
  try{
    if((parseInt(hora.charAt(0))>=0 && parseInt(hora.charAt(0))<2) && (hora.charAt(2) == ':') && (parseInt(hora.charAt(3))>=0 && parseInt(hora.charAt(3))<6) && (parseInt(hora.charAt(4))>= 0))
      return true;
    return false;
    /*En formato 24 horas, el horario de la facultad es mínimo de 0 que dudo que vaya alguien a las ocho ha jugar al pin pon hasta las las 20 */
  } catch(error){
    return false;
  }
}
  

function verificarFecha(fecha){
  /* Hacemos un try catch ya que pueden meter un caracter que no puede hacerse un parseInt */
  try{
    if((parseInt(fecha.charAt(0))<=3) && (fecha.charAt(2) == '/') && (parseInt(fecha.charAt(3)))<2 && (parseInt(fecha.charAt(4))) >=0){
      var fechaHoy = new Date();
      var arrFecha = pasarAFecha(fecha);
      //console.log(arrFecha)
      var DateReserva = new Date(arrFecha[1]+"/"+(arrFecha[0])+ "/"+fechaHoy.getFullYear()); /*Generamos la fecha de la reserva en formato date.*/
      if (DateReserva.getMonth() < fechaHoy.getMonth() || (DateReserva.getMonth() === fechaHoy.getMonth() && DateReserva.getDate() < fechaHoy.getDate())) {
        /* La reserva ya habría pasado de este año, generamos otro nuevo date que lo que va a hacer es comprobrar cuantos días quedan para la misma.*/
        var dateSiguienteAno = new Date(arrFecha[1]+"/"+arrFecha[0]+ "/"+(fechaHoy.getFullYear()+1));
        //console.log(dateSiguienteAno.toString());
        var diferenciaEnMilisegundos = Math.abs(dateSiguienteAno - fechaHoy);
        var diferenciaEnDias = diferenciaEnMilisegundos / (1000 * 60 * 60 * 24);
        if(diferenciaEnDias>diasAntelacionReserva){
          //console.log('Entro aqui' + diferenciaEnDias + " " + diasAntelacionReserva);
          return false;
        }
      } else {
        /*La fecha todavía no ha ocurrido únicamente debemos verificar que está en un tiempo inferior a uno determinado. */
        var diferenciaEnMilisegundos = Math.abs(DateReserva-fechaHoy);
        var diferenciaEnDias = diferenciaEnMilisegundos / (1000 * 60 * 60 * 24);
        if(diferenciaEnDias>diasAntelacionReserva)
          return false;
      }
      return true;
    }
  } catch (error){
    return false;
  }
}

function member(userID, arr, tenerEncuentaAdmins){
  /*Función que verifica si un usuario ya hecho la reserva un día, los administradores estarán libres de ello por si es para algún evento. */
  if(adminsIDS.indexOf(userID) != -1 && tenerEncuentaAdmins == 0){
    return false;
  } else if(arr.indexOf(userID)!=1){
    return true;
  }
  return false;
}
async function mostrarInformacionReservas(db){
  let longitud = db.longitud;
  var texto = "```";
  for(i = 0; i < longitud; i++){
    usuario = await client.users.fetch(db.arrayUserID[i]);
    texto +=  `${usuario.displayName}: ${db.arrayHoraInicio[i]} ~ ${db.arrayHoraFin[i]} Mesa: ${db.arrayMesas[i]}\n`
  }
  texto += "```"
  return texto;
}
// Definir la función para verificar solapamiento
function seSolapan(reserva1FechaInicio,reserva1FechaFin, reserva2FechaInicio, reserva2FechaFin) {
  // Verificar solapamiento de fechas
  if (reserva1FechaFin <= reserva2FechaInicio || reserva2FechaFin <= reserva1FechaInicio) {
      return false;  // No hay solapamiento de fechas
  }

  // Verificar solapamiento de horarios
  if (reserva1FechaFin <= reserva2FechaInicio || reserva2FechaFin <= reserva1FechaInicio) {
      return false;  // No hay solapamiento de horarios
  }

  // Si no se cumple ninguna de las condiciones anteriores, hay solapamiento
  return true;
}

function verificarTiempoantelacion(fechaReserva){
  var fechaManana = new Date();
  fechaManana.setDate(fechaManana.getDate() + 1);

  var arrFecha = pasarAFecha(fechaReserva);
  var fechaReservaDate = new Date();
  fechaReservaDate.setDate(arrFecha[0]);
  fechaReservaDate.setMonth(arrFecha[1]-1);
  var diferenciaEnMilisegundos = Math.abs(fechaManana - fechaReservaDate);
  var diferenciaEnDias = diferenciaEnMilisegundos / (1000 * 60 * 60 * 24);
  return (diferenciaEnDias <=1) ? false: true;
}
function pasarAFecha(fechaReserva){
  var DiaDecena = parseInt(fechaReserva.charAt(0))*10;
  var DiaUd = parseInt(fechaReserva.charAt(1));
  var Dia =  DiaDecena + DiaUd;
  var MesDecena = parseInt(fechaReserva.charAt(3))*10;
  var MesUd = parseInt(fechaReserva.charAt(4));
  var mes = MesDecena+MesUd;
  return [Dia, mes];
}

function sacarTiempoOn(){
  var segundos = client.uptime / 1000;
  horas = 0;
  dias = 0;
  semana = 0;
  minutos = Math.floor(segundos / 60);
  segundos = Math.floor(minutos%60 );
  horas = Math.floor(minutos/60);
  minutos = Math.floor(minutos%60);
  dias = Math.floor(horas/24);
  horas = Math.floor(horas%24);
  semana = Math.floor(dias/168);
  dias = Math.floor(dias%168);
  return [semana, dias, horas, minutos, segundos];
}
function verificarCorreoInstitucional(correo){
  if(correo.includes('@alumnos.upm.es'))
    return false;
  else
    return true;
}