// Require the necessary discord.js classes
//Client, Events, GatewayIntentBits, Partials
const {GuildScheduledEventEntityMetadataOptions, GuildScheduledEventEntityType, GuildScheduledEventPrivacyLevel,  GuildScheduledEventManager, AttachmentBuilder, Client, Events, GatewayIntentBits, Partials, EmbedBuilder, IntegrationApplication, Embed} = require('discord.js');
const {parentTempChannels, canalEventos, inviteServer, sugDeneg, sugerenciasImpl, logsTicket, canalSugerencias , idGoogleSheets, logComandos, canalBienvenida, MensajeStatus, token, CLIENT_ID, numMesas, adminsIDS, emojiAperturaTicket, guildID, categoriaTicketsID, idRoleSoporte, canalLogsMd, numeroM치ximoReservasUser, diasAntelacionReserva} = require('./config.json');
const fs = require('fs');
const os = require('os');
const CPU = require('os-utils');
// Create a new client instance
//: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMessageReactions],
//GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMessageReactions
const client = new Client({ intents: [GatewayIntentBits.GuildPresences, GatewayIntentBits.GuildVoiceStates, GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.GuildMessageReactions, GatewayIntentBits.DirectMessages, GatewayIntentBits.DirectMessageReactions], partials: [ Partials.Message, Partials.Channel, Partials.Reaction, Partials.User, Partials.GuildScheduledEvent]});

// When the client is ready, run this code (only once).
// The distinction between `client: Client<boolean>` and `readyClient: Client<true>` is important for TypeScript developers.
// It makes some properties non-nullable.

//La fecha del date es en formato americano

/*
  Cargamos bases de datos necesarias.
*/
const dbReservas = JSON.parse(fs.readFileSync("./databases/reservas.json", "utf8"));
const dbReservasEscribir = require("./databases/reservas.json");
const dbReactionRole = JSON.parse(fs.readFileSync("./databases/reactionrole.json"));
const dbReactionRoleEscribir = require("./databases/reactionrole.json");
const dbUseraServer = JSON.parse(fs.readFileSync("./databases/useraserver.json"));
const dbUseraServerEscribir = require("./databases/useraserver.json");
const dbServeraUser = JSON.parse(fs.readFileSync("./databases/serverauser.json"));
const dbServeraUserEscribir = require("./databases/serverauser.json");
const bloqueadosModmail = JSON.parse(fs.readFileSync("./databases/bloqueadosmodmail.json"));
const bloqueadosModmailEscribir = require("./databases/bloqueadosmodmail.json");
const dbReservasHechasPorUser = JSON.parse(fs.readFileSync("./databases/reservashechasporuser.json"));
const dbReservasHechasPorUserEscribir = require("./databases/reservashechasporuser.json");
const dbSugerencias = JSON.parse(fs.readFileSync("./databases/sugerencias.json"));
const dbSugerenciasEscribir = require("./databases/sugerencias.json");
const dbTempchanels = JSON.parse(fs.readFileSync("./databases/tempchannels.json"));
const dbTempchanelsEscribir = require("./databases/tempchannels.json");
const dbTorneosParticipando = JSON.parse(fs.readFileSync("./databases/torneosparticipando.json"));
const dbTorneosParticipandoEscribir = require("./databases/torneosparticipando.json"); /* Guardamos el torneo y un array con las ids participantes */
/* API de google para los sheets: */
//bot-discordjs-sheets-407312-308c06575d72.json
const { GoogleSpreadsheet } = require('google-spreadsheet');
const { JWT } = require('google-auth-library');
var creds = require('./credenciales_google/bot-discordjs-sheets-407312-308c06575d72.json');
// Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
const serviceAccountAuth = new JWT({
  // env var values here are copied from service account credentials generated by google
  // see "Authentication" section in docs for more info
  email: creds.client_email,
  key: creds.private_key,
  scopes: [
    'https://www.googleapis.com/auth/spreadsheets',
  ],
});

/*-------------------------------------------------- */
//Verificaci칩n para borrar de la database reservas de dias anteriores. (Esto se ejecutar치 cada 15 minutos por ejemplo).

setInterval(()=>{
  for (var clave in dbReservasEscribir) {
    if (dbReservasEscribir.hasOwnProperty(clave)) {
      // Accede al valor correspondiente utilizando la clave
      var arrFecha = pasarAFecha(clave);
      var fechaHoy = new Date();
      var DateReserva = new Date(arrFecha[1]+"/"+(arrFecha[0])+ "/"+fechaHoy.getFullYear());
      //console.log(fechaHoy);
      //console.log('===================')
     //console.log(DateReserva);
      if((fechaHoy.getDay()  == DateReserva.getDay()) && (fechaHoy.getMonth() == DateReserva.getMonth() ) && (fechaHoy.getFullYear() == DateReserva.getFullYear())){
        /* Significa que la fecha de la reserva es el dia de hoy.
           Ahora debemos verificar que haya pasado la hora de inicio.
        */
        dbReservasEscribir[clave].arrayHoraInicio.forEach(async horasInicio =>{
          if(fechaHoy.getHours() >= parseInt(horasInicio)){
            /* Ya ha pasado la hora de la reserva */
            let pos = dbReservasEscribir[clave].arrayHoraInicio.indexOf(horasInicio);
            var userID = dbReservasEscribir[clave].arrayUserID[pos];
            if(dbReservasEscribir[clave].longitud != 1){
              /* Debemos preservar las fechas existentes posteriores. */
              dbReservasEscribir[clave].arrayHoraInicio = eliminarDelArray(dbReservasEscribir[clave].arrayHoraInicio, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].arrayHoraFin = eliminarDelArray(dbReservasEscribir[clave].arrayHoraFin, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].arrayMesas = eliminarDelArray(dbReservasEscribir[clave].arrayMesas, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].arrayUserID = eliminarDelArray(dbReservasEscribir[clave].arrayUserID, pos, dbReservasEscribir[clave].longitud);
              dbReservasEscribir[clave].longitud = dbReservasEscribir[clave].longitud -1;
            } else {
              /*Nos cargamos los datos del d칤a de hoy. */
              delete dbReservasEscribir[clave];
            }
            await escribirDatos(1);
            /*En cualquiera de los casos tenemos que liberar la reserva hecha por el user en sus datos */
            if(dbReservasHechasPorUserEscribir[userID].numReservas != 1){
              dbReservasHechasPorUserEscribir[userID].numReservas = dbReservasHechasPorUserEscribir[userID].numReservas -1;
            } else {
              delete dbReservasHechasPorUserEscribir[userID];
            } 
            await escribirDatos(6);
          }
        });
      }
    }
  }
}, 900000);


/*-------------------------------------------------- */
/*Datos de actualizaci칩n del status del bot y recursos. */
client.on('ready', async () => {
  setInterval(async () => {
    arrTiempo = sacarTiempoOn(); /*Semana, dias , horas, minutos y segundos */
    const index = Math.floor(Math.random() * ((actividades.length-1) - 0 + 1)) + 0; // Genera un numero aleatorio entre 1 y la longitud de la lista de actividades.
    client.user.setPresence({ activities: [{ name: `${actividades[index]}` }], status: 'online' });
    const guild = await  client.guilds.resolve(guildID);
    const ch = await guild.channels.resolve(MensajeStatus[0]);
    const categoria = await client.channels.resolve(parentTempChannels);
    let cantidadTempchannels = categoria.children.cache.size;
    await ch.messages.fetch(MensajeStatus[1]).then(async msg =>{
      CPU.cpuUsage(async function(ConsumoCpu) {
        embedStatus = new EmbedBuilder()
        .setTitle(`Status del bot`)
        .setColor(`Aqua`)
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription(`Mensaje autom치ticamente actualizado por el bot donde informa del estado del bot, su consumo de recursos y otros datos importantes.`)
        .setTimestamp()
        .addFields({ name: 'Cantidad de reservas pendientes', value: `${Object.keys(dbReservasEscribir).length}`, inline: true },
                  { name: `Cantidad de tickets abiertos:`, value: `${Object.keys(dbServeraUserEscribir).length}`, inline: true },
                  { name: `Consumo de cpu`, value: '``'+(ConsumoCpu*100)+'``', inline: true},
                  { name: `Consumo de RAM: `, value:  '``' + (os.totalmem() - os.freemem()) / os.totalmem()* 100 + '%``', inline: true},
                  { name: `Plataforma: `, value: os.platform(), inline: true},
                  { name: `Uptime:`, value: arrTiempo[0] + ' ``w`` ' + arrTiempo[1] + ' ``d`` ' + Math.round(arrTiempo[2]) + ' ``h`` ' + Math.round(arrTiempo[3]) + ' ``m`` ' + Math.round(arrTiempo[4]) + ' ``s``-> (' +client.uptime + ' ``ms``)'  },
                  { name: `Cantidad de tempchannels: `, value: '``' + cantidadTempchannels+ ' ``', inline: true}
                  )
        await msg.edit({embeds: [embedStatus]})
      });
    });
  }, 30000);
});

/*-------------------------------------------------*/
const { REST, Routes } = require('discord.js');


const commands = [
  /* Torneos */
  {
    name: 'finalizarplazoinscripcion',
    description: 'Finalizas el plazo de inscripci칩n a un torneo',
    options: [
      {
        name: 'nombre',
        description: 'Nombre del torneo a finalizar plazo de inscripci칩n',
        type: 3,
        required: true
      }
    ]
  },
  {
    name: 'establecerdbtorneo',
    description: 'Estableces un torneo en la database',
    options: [
      {
        name: 'tipo',
        description: 'Individual: 0, Parejas: 1',
        type: 4,
        required: true
      },
      {
        name: 'nombre',
        description: 'Nombre del torneo con el que la gente se deber치 apuntar 칰nica palabra para evitar errores',
        type: 3,
        required:true
      }
    ]
  },
  {
    name: 'torneo',
    description: 'Operaciones relacionadas con un torneo.',
    options: [
      {
        name: "apuntarse",
        description: 'Te apuntas a un torneo espec칤fico',
        type: 2,
        options:[
          {
            name: 'individual',
            description: 'Te apuntas a un torneo individual',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo individual en el que quieres participar.',
                required: true
              }, 
              {
                name: 'correo',
                type: 3,
                description: 'Correo institucional personal', 
                required: true
              }
            ]
          },
          {
            name: 'parejas',
            description: 'Te apuntas a un torneo en parejas',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo parejas en el que quieres participar.',
                required: true
              },
              {
                name: 'correo',
                type: 3,
                description: 'Correo institucional personal', 
                required: true
              },
              {
                name: 'companero',
                type: 6,
                description: 'Persona con la que te inscribes. Si no tienes a nadie te emparejaremos manualmente.',
                required: false
              }, 
              {
                name: 'correocompanero',
                type: 3,
                description: 'Correo institucional personal de tu pareja', 
                required: false
              }
            ]
          }
        ]
      },
      {
        name: "desapuntarse",
        description: 'Te desapuntas a un torneo espec칤fico',
        type: 2,
        options:[
          {
            name: 'individual',
            description: 'Te desapuntas a un torneo individual',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo individual en el que quieres desapuntarte.',
                required: true
              }
            ]
          },
          {
            name: 'parejas',
            description: 'Te desapuntas a un torneo en parejas',
            type: 1,
            options: [
              {
                name: 'nombre',
                type: 3,
                description: 'Nombre del torneo parejas en el que quieres desapuntarte.',
                required: true
              }
            ]
          }
        ]
      }
    ]
  },
  /* Reglamento */
  {
    name: 'reglamentoindividual',
    description: 'Env칤as el reglamento en un canal determinado',
    options: [{
      name: 'channel',
      type: 7,
      required: true, 
      description: 'Canal donde debo enviarlo'
    }]
  },
  /* Reglas */
  {
    name: 'reglas',
    description:'Envias el mensaje de reglas del servidor',
    options: [
      {
        name: 'channel',
        type: 7,
        required: true,
        description: 'Canal donde envias las reglas del servidor'
      }
    ]
  },
  /* FAQ */
  {
    name: 'enviarfaq',
    description: 'Env칤as las faq a un canal determinado',
    options: [{
      name: 'canal',
      type: 7,
      description: 'Lugar donde quieres enviar los FAQ',
      required: true
    },
    {
      name: 'opcion',
      type: 4,
      description: 'Eliges la opcion de la que quieres los faq.',
      required: true
    }
    ]
  },
  /* TempChannels */
  {
    name: 'creartempchannels',
    description: 'Creas un canal como tempchannel',
    options:[
      {
        name: 'canal',
        description: 'Canal que estableces como tempchannel',
        type: 7,
        required: true
      },
      {
        name: 'cantidaduser',
        description: 'Cantidad de usarios para el canal',
        type: 4,
        required: false
      }
    ]
  },
  /* Crear eventos */
  {
    name: 'crearevento',
    description: 'Creas un evento en el servidor de discord',
    options: [{
      name: 'titulo',
      required: true,
      description: 'Titulo del eveto',
      type: 3
    },
    {
      name: 'descripcion',
      description: 'Descripci칩n del evento',
      type: 3,
      required: true
    },
    {
      name: 'fechainicio',
      required: true,
      description: 'Formato dd/mm',
      type: 3
    },
    {
      name: 'fechafin',
      required: true,
      description: 'Formato dd/mm',
      type: 3
    },
    {
      name: 'location',
      type: 3,
      description: 'Localizaci칩n, por default la escuela.',
      required: false
    }]
  },
  /* say*/
  {
    name: 'say',
    description: 'dices algo con el bot',
    options: [
      {
        name: 'content',
        description: '쯈u칠 quieres decir?',
        type: 3,
        required: true
      }
    ]
  },
  /* Info sobre bots */
  {
    name: 'musicbot',
    description: 'Muestras informaci칩n b치sica de ayuda sobre el bot de musica.'
  },
  /* Sugerencias*/
  {
    name: 'denegarsugerencia',
    description: 'Deniegas una sugerencia',
    options: [{
      name: 'idsugerencia',
      type: 3,
      description: 'Id de la sugerencia que quieres denegar',
      required: true
    },
    {
      name: 'reason',
      description: 'Raz칩n por la cual deniegas la sugerencia',
      type: 3,
      required: true
    }]
  },
  {
    name: 'sugerenciaimplementada',
    description: 'Marcas como implementada la sugerencia.',
    options: [
      {
        name: 'idsugerencia',
        description: 'Id de la sugerencia implementada',
        type: 3,
        required: true
      }
    ]
  },
  {
    name: 'sugerir',
    description: 'realizas una sugerencia',
    options:[{
      name: 'contenido',
      description: 'sugerencia',
      type: 3, 
      required: true
    },
    {
      name: 'adjunto',
      type: 11,
      description: 'Posible contenido adjunto.',
      required: false
    }]
  },
  /*Embeds autom치ticos para el reaction role*/
  {
    name: 'reactionroleembeds',
    description: 'Env칤as los mensajes.', 
    options:[{
      name: 'canal',
      description: 'Canal donde vas a enviar la informaci칩n',
      type: 7,
      required: true
    }]
  },
  /*Generar invite eterna a un servidor donde generes el comando*/
  {
    name: 'generarinvite',
    description: 'Generas invite'
  }, 
  /* Status del desarrollo */
  {
    name: 'status',
    description: 'Muestras el status del bot'
  },
  /*Reserva de mesas*/
  {
    name: 'ping',
    description: 'Muestras el ping del bot',
  },
  {
    name: 'reservamesa',
    description: 'Solicitud de reserva de mesa.',
    options: [{
      name: 'fecha',
      description: 'Proporciona la fecha en formato dd/mm. Solo puedes reservar con 6 meses de antelaci칩n',
      type: 3,
      required: true
    },
    {
      name: 'horainicio',
      description: 'Proporciona la hora en formato 24 horas con hh:mm',
      type: 3,
      required: true
    },
    {
      name: 'horafin',
      description: 'Proporciona la hora en formato 24 horas con hh:mm',
      type: 3,
      required: true
    },
    {
      name: 'mesa',
      description: 'Elijes el n칰mero de mesa a reservar.',
      type: 4,
      required: false
    }]
    
  },
  {
    name: 'cancelarreserva',
    description: 'Cancelas una reserva que ten칤as programada.',
    options: [{
      name: 'fecha',
      description: 'Proporciona la fecha de tu reserva en formato dd/mm',
      type: 3, 
      required: true
    }]
  },
  {
    name: 'mostrarreservas',
    description: 'Muestras la informaci칩n de las reservas en una fecha determinada.',
    options: [{
      name: 'fecha',
      description: 'Proporciona la fecha a consultar',
      type: 3,
      required: true
    }]
  },
  {
    name: 'borrarreserva',
    description: 'Borras la mesa de un usuario en una determinado fecha y hora. El usuario recibir치 la raz칩n.',
    options:[{
      name: 'user',
      type: 6,
      required: true,
      description: 'Usuario titular de la reserva'
    },
    {
      name: 'fecha',
      description: 'Fecha en la que est치 planificada la reserva',
      type: 3,
      required: true
    },
    {
      name: 'reason',
      description: 'Raz칩n por la cual cancelas la reserva.',
      type: 3,
      required: true
    }]
  },

  /* Reaction role */
  {
    name: 'addreactionrole',
    description: 'Creas un reaction role. Luego te pedir치 que reacciones con el emoji deseado.',
    options: [{
      name: 'messageid',
      description: 'ID del mensaje para el reaction role',
      type: 3,
      required: true
    },
    {
      name: 'role',
      description: 'Role a entregar',
      type: 8, /*Guardamos un tipo String ya que los posibles salvados num칠ricos no son lo suficientemente grandes */
      required: true
    },
    {
      name: 'canalmensaje',
      description: 'Canal donde est치 situado el mensaje del reactionrole',
      type: 7,
      required: true
    }]
  },
  {
    name: 'removereactionrole',
    description: 'Eliminas un reaction role',
    options: [{
      name: 'messageid',
      description: 'ID del mensaje para el reaction role',
      type: 3,
      required: true
    },
    {
      name: 'canalmensaje',
      description: 'Canal donde est치 situado el mensaje del reactionrole',
      type: 7,
      required: true
    }]
  },
  /* Modmail*/
  {
    name: 'reply',
    description: 'Respondes a un mensaje en modmail',
    options: [{
      name: 'contenido',
      description: 'Contenido de texto que respondes al usuario',
      type: 3,
      required: true
    },
    {
      name:'adjunto',
      description: 'Posible contenido adjunto',
      type: 11,
      required: false
    }]
  },
  {
    name: 'contactar',
    description: 'Inicias un contacto de modmail con un usuario.',
    options: [
      {
        name: 'user',
        description: 'Usuario al que quieres contactar',
        type: 6,
        required: true
      },
      {
        name: 'reason',
        description: 'Raz칩n del contacto\nLa raz칩n la recibe el usuario.',
        type: 3,
        required: true
      }
    ]
  },
  {
    name: 'cerrarticket',
    description: 'Cierras un ticket en curso'
  },
  {
    name: 'bloquearuser',
    description: 'Bloqueas a un usuario del uso del modmail',
    options: [{
      name: 'user',
      description: 'user al que aplicas el ban',
      required: true,
      type: 6
    },
    {
      name: 'reason',
      description: 'Raz칩n a la que se debe el ban',
      required: true,
      type: 3
    }]
  },
  {
    name: 'editarmensajeticket',
    description: 'Editas un mensaje de un ticket enviado por el staff',
    options:[{
      name: 'newcontent',
      description: 'Nuevo contenido en el mensaje a editar',
      type: 3,
      required: true
    },
    {
      name: 'idmensaje',
      description: 'La id del mensaje a editar en el servidor',
      type: 3,
      required: true
    }]
  },
  {
    name: 'desbloquearuser',
    description: 'Desbloqueas a un usuario del uso del modmail',
    options: [{
      name: 'user',
      description: 'El usuario al que quieres desbloquear',
      type: 6,
      required: true
    }]
  }
];

const rest = new REST({ version: '10' }).setToken(token);

try {
  console.log('Recargando slash commands.');

   //rest.put(Routes.applicationCommands(CLIENT_ID), { body: commands }); Esto lo hace en todo tanto md's como servidor.
   rest.put(Routes.applicationGuildCommands(CLIENT_ID, guildID), { body: commands }); /*Creamos 칰nicamente en el guild, esto es para que no se creen en el md y otros servidores. */



  console.log('Slash Commands recargados');
} catch (error) {
  console.error(error);
}
const actividades = ["Ping",  "Pong"];

/*client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
});*/
/* SLASH COMMANDS */
client.on('interactionCreate', async interaction => {
  if (!interaction.isChatInputCommand()) return;
  if(bloqueadosModmailEscribir[interaction.member.id])
    return interaction.reply({content: `Est치s bloqueado del uso del bot`, ephemeral: true});
  if (interaction.commandName === 'ping') {
    await interaction.reply({content: `游끱 Pong actual: ${Math.abs(Date.now() - interaction.createdAt)}` , ephemeral: true});
  } else if(interaction.commandName == 'reservamesa'){
    let fechaInicio = await interaction.options.getString('fecha');
    let horaInicio = await interaction.options.getString('horainicio');
    let horaFin = await interaction.options.getString('horafin');
    if(dbReservasHechasPorUserEscribir[interaction.member.id]){
      if(dbReservasHechasPorUserEscribir[interaction.member.id].numReservas >= numeroM치ximoReservasUser && adminsIDS.indexOf(interaction.member.id) == -1)
        return interaction.reply({content: "Has hecho tu n칰mero m치ximo de reservas espera a haber realizado tu reserva.\n Si crees que se trata de un error escr칤beme un md", ephemeral: true});
    }
    if(horaInicio> horaFin)
      return interaction.reply({content: 'La colocaci칩n de las horas es incorrecta.', ephemeral: true});
    let mesa = await interaction.options.getInteger('mesa');
    if((mesa <1 || mesa > numMesas) && mesa !=null ) return interaction.reply('La mesa no existe');
    if(!(verificarHoras(horaInicio) && verificarHoras(horaFin) && verificarFecha(fechaInicio)))
      return interaction.reply('Formato de fechas o horas incorrecto, verifica que la fecha est치 en formato dd/mm y la hora hh:mm. \n En caso de haberlo proporcionado bien 칰nicamente puedas reservar con seis meses de antelaci칩n.');
    if(!verificarTiempoantelacion(fechaInicio) && adminsIDS.indexOf(interaction.member.id) == -1) //Debe no ser admin y menos de 24 horas.
      return interaction.reply({content: `Debes reservar con m치s de 24 horas de antelaci칩n.`});
    if(dbReservasEscribir[fechaInicio]){
      mesa = (mesa == null) ? buscarMesa(horaInicio, horaFin, dbReservasEscribir[fechaInicio]) : verificarMesa(mesa, fechaInicio, horaInicio, horaFin);
      if(mesa == -1){
        return interaction.reply({content : 'No disponible la mesa en espec칤fico o ese horario en general.', ephemeral: true});
     }
     if(member(interaction.member.id, dbReservasEscribir[fechaInicio].arrayUserID,0))
      return interaction.reply('No puedes tener m치s de una reserva en un d칤a.');
     dbReservasEscribir[fechaInicio].arrayHoraInicio = anadirDelArray(dbReservasEscribir[fechaInicio].arrayHoraInicio, horaInicio, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].arrayHoraFin = anadirDelArray(dbReservasEscribir[fechaInicio].arrayHoraFin, horaFin, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].arrayMesas = anadirDelArray(dbReservasEscribir[fechaInicio].arrayMesas, mesa, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].arrayUserID = anadirDelArray(dbReservasEscribir[fechaInicio].arrayUserID, interaction.member.id, dbReservasEscribir[fechaInicio].longitud);
     dbReservasEscribir[fechaInicio].longitud = dbReservasEscribir[fechaInicio].longitud +1; 
     escribirDatos(1);     
    } else {
      if(mesa < 0 || mesa > numMesas){
        return interaction.reply('Esa mesa no existe');
      }
      mesa = (mesa == null) ? 1: mesa;
      arrayHoraInicio = [horaInicio];
      arrayHoraFin = [horaFin];
      arrayMesas = [1];
      arrayUserID = [interaction.member.id];
      longitud = 1;
      dbReservasEscribir[fechaInicio] = {arrayHoraInicio, arrayHoraFin, arrayMesas, arrayUserID, longitud};
      escribirDatos(1);      
    }
    numReservas = !(dbReservasHechasPorUserEscribir[interaction.member.id])? 1: dbReservasHechasPorUserEscribir[interaction.member.id].numReservas+1;
    dbReservasHechasPorUserEscribir[interaction.member.id] = {numReservas}
    await escribirDatos(6)

    interaction.reply('Reserva con 칠xito').then(async msg =>{
       /*Intentamos escribir un md al usuario para informarle de su reserva de ping pong, con el riesgo de que el usuario no tenga abiertos los md con el bot, luego realizamos un try{} catch.
        En caso de que no pueda localizar por md, lo env칤a al canal donde se ejecut칩 el comando.
       */
      try{
          usuarioReserva = await client.users.fetch(interaction.member.id);
          const embedReserva = new EmbedBuilder()
          .setColor('Green')
          .setTitle('Informaci칩n de reserva de la mesa de ping pong.')
          .setAuthor({name: interaction.member.displayName, avatarURL: interaction.member.avatarURL()})
          .setDescription(`Mesa ${mesa}`)
          .addFields({name: 'Cuenta de discord titular de la reserva:', value: interaction.member.displayName }, {name: 'Fecha de inicio: ', value: fechaInicio}, {name: 'Hora de inicio:', value: horaInicio}, {name: 'Hora de finalizaci칩n:', value: horaFin}, {name: 'Reserva realizada con 칠xito.',  value: '\u200B'})
          .setFooter({ text: '游끱 Buenas partidas 游끱', iconURL: client.user.avatarURL()});
          await usuarioReserva.send({ embeds: [embedReserva] });
      }catch(error){
        const embedReserva = new EmbedBuilder()
          .setColor('Green')
          .setTitle('Informaci칩n de reserva de la mesa de ping pong.')
          .setAuthor({name: interaction.member.displayName, avatarURL: interaction.member.avatarURL()})
          .setDescription(`Mesa ${mesa}`)
          .addFields({name: 'Cuenta de discord titular de la reserva:', value: interaction.member.displayName }, {name: 'Fecha de inicio: ', value: fechaInicio}, {name: 'Hora de inicio:', value: horaInicio}, {name: 'Hora de finalizaci칩n:', value: horaFin}, {name: 'Reserva realizada con 칠xito.',  value: '\u200B'})
          .setFooter({ text: '游끱 Buenas partidas 游끱', iconURL: client.user.avatarURL()});
          msg.edit({content: 'No he podido localizarte por md, seguramente tendr치s bloqueados los mensajes directos de este servidor, adjunto informaci칩n de la reserva por aqu칤.\nNota: Informaci칩n de discord para permitir mensajes directos de este servidor. [Pulsa aqu칤.](https://support.discord.com/hc/es/articles/217916488-Ajustes-de-bloqueo-y-privacidad#h_01HD4ANCTGAS1RCVZVY1F4CHGS)', embeds: [embedReserva]});
      }
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[1]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { User: `${interaction.member.displayName} -> (${interaction.member.id})`, Fecha: `${fechaInicio}`,  Hora_Inicio: `${horaInicio}`, Hora_Fin: `${horaFin}`, Mesa: mesa}
        ]);
      }catch(error){
        console.log(error)
      }
    });
   
  } else if(interaction.commandName === 'cancelarreserva'){
    let fecha = interaction.options.getString('fecha');
    if(!verificarFecha(fecha))
      return interaction.reply('Fecha en formato err칩neo. Debe ser en formato dd/mm\nEn caso de tener buen formato puedes consultar como m치ximo en un transcurso de seis meses.');
    if(dbReservasEscribir[fecha]){
      
      if(member(interaction.member.id,dbReservasEscribir[fecha].arrayUserID, 1)){
        /*Este usuario ten칤a una reserva para esa fecha.*/
        if(dbReservasEscribir[fecha].longitud == 1){
          /*칔nicamente ese usuario ten칤a reserva para esa fecha, luego hay que borrar todo */
          delete dbReservasEscribir[fecha];
          escribirDatos(1);
        } else{
          /*No solamente est치 ese usuario de reserva */
          /*Necesitamos saber en qu칠 posici칩n para borrar esa reserva */
          let pos = dbReservasEscribir[fecha].arrayUserID.indexOf(interaction.member.id);
          dbReservasEscribir[fecha].arrayHoraInicio = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraInicio, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayHoraFin = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraFin, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayMesas = eliminarDelArray(dbReservasEscribir[fecha].arrayMesas, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayUserID = eliminarDelArray(dbReservasEscribir[fecha].arrayUserID, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].longitud = dbReservasEscribir[fecha].longitud -1;
          escribirDatos(1);
          
        }
        numReservas = dbReservasHechasPorUserEscribir[interaction.member.id].numReservas -1;
        if(numReservas != 0){
          dbReservasHechasPorUserEscribir[interaction.member.id] = {numReservas};
          escribirDatos(6);
        } else {
          delete dbReservasHechasPorUserEscribir[interaction.member.id];
          escribirDatos(6);
        }
        await interaction.reply('Reserva cancelada con 칠xito.').then(async msg =>{
          try{
            usuarioReserva = await client.users.fetch(interaction.member.id);
            await usuarioReserva.send({content: 'Su reserva ha sido cancelada con 칠xito para la fecha: ' + fecha});
          } catch(e){
            await msg.edit({content: 'No he podido localizarte por md, seguramente tendr치s bloqueados los mensajes directos de este servidor, adjunto informaci칩n de la reserva por aqu칤.\nNota: Informaci칩n de discord para permitir mensajes directos de este servidor. [Pulsa aqu칤.](https://support.discord.com/hc/es/articles/217916488-Ajustes-de-bloqueo-y-privacidad#h_01HD4ANCTGAS1RCVZVY1F4CHGS) \nSu reserva ha sido cancelada con 칠xito para la fecha: ' + fecha});
          }
        });
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[1];
        const userBorrar = `${interaction.member.displayName} -> (${interaction.member.id})`;
        const fechaaborrar = `${fecha}`
        /* Vamos a intentar borrar por nombre. */
        await sheet.loadCells();
        // Encontrar y eliminar la fila
        const rows = sheet.rowCount;
        continuar = true;
        for (let i = 0; i < rows && continuar; i++) {
          const cell1 = sheet.getCell(i, 0); 
          const cell2 = sheet.getCell(i, 1)
          if (cell1.value === userBorrar && cell2.value == fechaaborrar) {
            sheet.clearRows({start: i+1, end: i+1});
            continuar = false;
          }
        } 
        
      } else {
        return interaction.reply('No tiene ninguna reserva en esa fecha.');
      }
    }else {
      return interaction.reply('No hab칤a ninguna reserva en esa fecha.');
    }
  }else if(interaction.commandName === 'mostrarreservas'){
    let fecha = await interaction.options.getString('fecha');
    if(!(verificarFecha(fecha)))
      return interaction.reply('Fecha en formato err칩neo.\nEn caso de haberlo puesto en formato correcto como m치ximo puedes consultar en seis meses de distancia.');
    if(dbReservasEscribir[fecha]){
      var texto = await mostrarInformacionReservas(dbReservasEscribir[fecha]);
      const embedReservas = new EmbedBuilder()
      .setColor('Green')
      .setTitle(`Informaci칩n de la reserva en la fecha: ${fecha}`)
      .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
      .setDescription(texto)
      .addFields({name: `Puedes ver en tiempo real en este enlace como est치n las reservas: `, value: `[Google Sheets](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)`})
      .setTimestamp()
      interaction.reply({embeds: [embedReservas]});
    }else {
      /*Caso  de que no haya reserva en esa fecha*/
      interaction.reply({content: 'No hay ninguna reserva para esa fecha.\nPuedes ver en tiempo real las reservas a trav칠s del siguiente [Google Sheets](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)'});
    }

  } 
  /*Reaction role. */
  else if(interaction.commandName == 'addreactionrole'){
    try{
      let messageid = await interaction.options.getString('messageid');
      let role = await interaction.options.getRole('role');
      let canal = await interaction.options.getChannel('canalmensaje');
      const channel = await client.channels.fetch(canal.id);
      const mensaje = await channel.messages.fetch(messageid);
      const roleEntregar = await interaction.guild.roles.fetch(role.id);
      const botServer = await interaction.guild.members.fetch(client.user.id);
      await botServer.roles.add(role.id);
      if(channel.type != 0)
        return interaction.reply('Solo puedo hacer reactions role en canales de texto normales.\nNo puedo en threads.');
      const msg = await interaction.reply({content: 'Reacciona en este mensaje el emoji al que deben reaccionar. \nSolo dispones de 1 minuto para ello.', fetchReply: true });
      const filter = (reaction, user) => {
        user.id === interaction.member.id && msg.id === reaction.message.id;
      };
      var salvado = false; // Salvaguarda para solo guardar un emoji por comando.
      const Collector = msg.createReactionCollector(filter, { time: 120000, max: 1 });
      Collector.on('collect', async reaction => {
        emoji = (reaction.emoji.id== null) ? reaction.emoji.name : reaction.emoji.id;
        if(salvado) return;
        if(dbReactionRoleEscribir[mensaje.id]){
          if( dbReactionRoleEscribir[mensaje.id].canalID === channel.id){
            /*Este mensaje ya pose칤a alg칰n reaction role anterior.*/
            dbReactionRoleEscribir[mensaje.id].emojis = anadirDelArray(dbReactionRoleEscribir[mensaje.id].emojis, emoji, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].role = anadirDelArray(dbReactionRoleEscribir[mensaje.id].role, roleEntregar.id, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].longitud = dbReactionRoleEscribir[mensaje.id].longitud+1;
            await escribirDatos(2);
          }
        } else {
          emojis = [emoji];
          role = [roleEntregar.id];
          var canalID = channel.id;
          longitud = 1;
          dbReactionRoleEscribir[mensaje.id] = {canalID, emojis, role, longitud};
          await escribirDatos(2);
        }
        await mensaje.react(emoji);
        await interaction.editReply({content: 'ReactionRole establecido con 칠xito', ephemeral: true});
        salvado = true;
      });

    } catch(error){
      /*Devuelve al usuario el error que se ha cometido:
        Pendiente para el github hacer una lista de los posibles errores y soluci칩n.
      */
      await interaction.reply({content: 'Se ha produciodo el siguiente error: \n' + error + '\nConsulta la documentaci칩n en github en b칰squeda de una posible soluci칩n.', ephemeral: true});
    }
  } else if(interaction.commandName == 'removereactionrole'){
    try {
      let messageid = await interaction.options.getString('messageid');
      let canal = await interaction.options.getChannel('canalmensaje');
      const channel = await client.channels.fetch(canal.id);
      const mensaje = await channel.messages.fetch(messageid);
      if(dbReactionRoleEscribir[mensaje.id] && dbReactionRole[mensaje.id].canalID == channel.id){
        //Existe en la database algunos de esos datos.
        // Ahora debo pedir el emoji que quieren que elimine.
        const msg = await interaction.reply({content: 'Reacciona en este mensaje el emoji al que deben reaccionar. \nSolo dispones de 1 minuto para ello.', fetchReply: true });
        const filter = (reaction, user) => {
          user.id === interaction.member.id && msg.id === reaction.message.id;
        };
        var salvado = false; // Salvaguarda para solo guardar un emoji por comando.
        const Collector = msg.createReactionCollector(filter, { time: 120000, max: 1 });
        Collector.on('collect', async reaction => {
          emoji = (reaction.emoji.id== null) ? reaction.emoji.name : reaction.emoji.id;
          if(salvado) return;
          if(dbReactionRoleEscribir[mensaje.id].longitud == 1){
            //Debo borrarlo de la database al completo.
            delete dbReactionRoleEscribir[mensaje.id];
            await escribirDatos(2);
          } else {
            // Mantenemos otros datos en la db.
            var pos = dbReactionRoleEscribir[mensaje.id].emojis.indexOf(emoji);
            dbReactionRoleEscribir[mensaje.id].emojis = eliminarDelArray(dbReactionRole[mensaje.id].emojis, pos, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].role = eliminarDelArray(dbReactionRole[mensaje.id].role, pos, dbReactionRoleEscribir[mensaje.id].longitud);
            dbReactionRoleEscribir[mensaje.id].longitud = dbReactionRoleEscribir[mensaje.id].longitud-1;
            await escribirDatos(2);
          }
          await interaction.editReply({content: 'Reaction role eliminado con exito.', ephemeral: true});
      });
      } else {
        interaction.reply({content: 'No existe ning칰n reaction role con esos datos en la database.', ephemeral: true});
      }
    }catch(error){

    }
  } else if(interaction.commandName === 'borrarreserva'){
    const user = interaction.options.getUser('user');
    const userFetched = await client.users.fetch(user.id);
    const fecha = interaction.options.getString('fecha');
    const reason = interaction.options.getString('reason');
    try{
      if(!verificarFecha(fecha))
        return interaction.reply({content: 'Fecha en formato incorrecto', ephemeral: true});
      if(dbReservasEscribir[fecha]){
        if(dbReservasEscribir[fecha].arrayUserID.indexOf(userFetched.id) == -1)
          return interaction.reply({content: `El ${userFetched.displayName} no tiene reserva en esa fecha.`, ephemeral: true});
        if(dbReservasEscribir[fecha].longitud == 1){
          /*칔nicamente ese usuario ten칤a reserva para esa fecha, luego hay que borrar todo */
          delete dbReservasEscribir[fecha];
          escribirDatos(1);
        } else{
          /*No solamente est치 ese usuario de reserva */
          /*Necesitamos saber en qu칠 posici칩n para borrar esa reserva */
          let pos = dbReservasEscribir[fecha].arrayUserID.indexOf(userFetched.id);
          dbReservasEscribir[fecha].arrayHoraInicio = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraInicio, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayHoraFin = eliminarDelArray(dbReservasEscribir[fecha].arrayHoraFin, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayMesas = eliminarDelArray(dbReservasEscribir[fecha].arrayMesas, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].arrayUserID = eliminarDelArray(dbReservasEscribir[fecha].arrayUserID, pos, dbReservasEscribir[fecha].longitud);
          dbReservasEscribir[fecha].longitud = dbReservasEscribir[fecha].longitud -1;
          escribirDatos(1);  
        }
      const guild = await client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedReservaBorrada = new EmbedBuilder()
      .setTitle(`Ticket cerrado`)
      .addFields({name: 'User', value:`${userFetched.displayName} -> (${userFetched.id})`},
                 {name: 'Staff', value: `${interaction.member.displayName}->(${interaction.member.id})`},
                 {name: 'Raz칩n', value: reason}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedReservaBorrada]});
      await userFetched.send(`Su reserva para la fecha ${fecha} fue cancelada por ${interaction.member.displayName} debido a ${reason}`);
      interaction.reply({content: `Reserva cancelada con exito`, ephemeral: true});
      const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = doc.sheetsByIndex[1];
        const userBorrar = `${interaction.member.displayName} -> (${interaction.member.id})`;
        const fechaaborrar = `${fecha}`
        /* Vamos a intentar borrar por nombre. */
        await sheet.loadCells();
        // Encontrar y eliminar la fila
        const rows = sheet.rowCount;
        continuar = true;
        for (let i = 0; i < rows && continuar; i++) {
          const cell1 = sheet.getCell(i, 0); 
          const cell2 = sheet.getCell(i, 1)
          if (cell1.value === userBorrar && cell2.value == fechaaborrar) {
            sheet.clearRows({start: i+1, end: i+1});
            continuar = false;
          }
        } 
        numReservas = dbReservasHechasPorUserEscribir[interaction.member.id].numReservas -1;
        if(numReservas != 0){
          dbReservasHechasPorUserEscribir[interaction.member.id] = {numReservas};
          escribirDatos(6);
        } else {
          delete dbReservasHechasPorUserEscribir[interaction.member.id];
          escribirDatos(6);
        }
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          const reservaSheet = await sheet.addRows([
            { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Borrar Reserva a ${user.displayName} -> (${user.id}).`, Reason: reason}
          ]);
        }catch(error){
          console.log(error)
        }
      } else {
        return interaction.reply({content: `No hay ninguna reserva en la fecha ${fecha}`});
      }
      
    }catch(error){
      interaction.reply(error);
    }
  }
   /* Modmail */
  else if(interaction.commandName === 'reply'){
    try{
      if(!dbServeraUserEscribir[interaction.channel.id])
        return interaction.reply({content: `Este canal de texto ${interaction.channel}, no est치 registrado como modmail.`, ephemeral: true});
      if(bloqueadosModmailEscribir[dbServeraUserEscribir[interaction.channel.id].idUser])
        return interaction.reply({content: `No puedes escribir a un usuario bloqueado`, ephemeral: true});
      const contenido = interaction.options.getString('contenido');
      var usuarioID =  dbServeraUserEscribir[interaction.channel.id].idUser;
      const user = await client.users.fetch(dbServeraUserEscribir[interaction.channel.id].idUser);
      const ch = interaction.channel;
      await user.send(contenido).then(async msg =>{
        await ch.send(`**STAFF**: \n ${interaction.member.displayName}`);
        const mensajeEnServer = await ch.send(contenido);
        var idMensajeEnUser = msg.id;
        var idMensajeEnServer = mensajeEnServer.id;
        dbUseraServerEscribir[usuarioID].mensajesEnUser = anadirDelArray(dbUseraServerEscribir[usuarioID].mensajesEnUser, idMensajeEnUser, dbUseraServerEscribir[usuarioID].longitud);
        dbUseraServerEscribir[usuarioID].mensajesEnServer = anadirDelArray(dbUseraServerEscribir[usuarioID].mensajesEnServer, idMensajeEnServer, dbUseraServerEscribir[usuarioID].longitud);
        dbUseraServerEscribir[usuarioID].longitud = dbUseraServerEscribir[usuarioID].longitud +1;
        dbServeraUserEscribir[ch.id].mensajesEnUser= dbUseraServerEscribir[usuarioID].mensajesEnUser;
        dbServeraUserEscribir[ch.id].mensajesEnServer = dbUseraServerEscribir[usuarioID].mensajesEnServer;
        dbServeraUserEscribir[ch.id].longitud = dbUseraServerEscribir[usuarioID].longitud;
        await escribirDatos(3);
        await escribirDatos(4);
        await interaction.reply({content: 'Funcion칩 correctamente', ephemeral: true});
        if(interaction.options.getAttachment('adjunto') != null){
          /*Significa que hay un adjunto en el c칩digo.*/
          const adjunto = interaction.options.getAttachment('adjunto').url;
          await ch.send(adjunto);
          await user.send(adjunto);
        }
        await ch.setTopic(`Ticket pendiente de la respuesta del usuario. \n 칔ltima interaccion ${new Date()}`);
      });
    } catch(error){
      interaction.reply({content: `Se ha producido el siguiente error: ${error}`, ephemeral: true});
    }
  } else if(interaction.commandName === 'contactar'){
    const user = await interaction.options.getUser('user');
    if(user.bot)
      return interaction.reply({content: `No puedes contactar a un bot`, ephemeral: true});
    if(bloqueadosModmailEscribir[user.id])
      return interaction.reply({content: `No puedes escribir a un usuario bloqueado.`, ephemeral: true});
    try{
      if(dbUseraServerEscribir[user.id])
        return interaction.reply({content: `El usuario ${user.displayName} ya tiene un ticket en curso en el canal <#${dbUseraServerEscribir[user.id].idChannel}>`, ephemeral: true});
      const userFetch = await  client.users.resolve(user.id);
      const guild = await client.guilds.resolve(guildID);
      await guild.channels.create({name: `ticket-${user.displayName}`, parent: categoriaTicketsID, topic: `Ticket pendiente de la respuesta del staff. \n 칔ltima interaccion ${new Date()}`}).then(async ch =>{
        const embedNuevoTicket = new EmbedBuilder()
        .setTitle(`Los staffs del servidor le han contactado`)
        .setAuthor({name: client.user.displayName, avatarURL: client.user.displayAvatarURL})
        .setColor('Green')
        .setDescription(`El contacto se produce desde el server ${guild.name}.`)
        .setTimestamp()
        await userFetch.send({embeds: [embedNuevoTicket]});
        const contenido = await interaction.options.getString('reason');
          await userFetch.send(contenido).then(async msg =>{
            await ch.send(`**STAFF**: \n ${interaction.member.displayName}`);
            const mensajeEnServer = await ch.send(contenido);
            var mensajesEnUser = [msg.id];
            var mensajesEnServer = [mensajeEnServer.id];
            var idChannel = ch.id;
            var longitud = 1;
            var idUser = user.id;
            dbUseraServerEscribir[user.id] = {idChannel, mensajesEnUser, mensajesEnServer, longitud};
            dbServeraUserEscribir[ch.id] = {idUser, mensajesEnUser, mensajesEnServer, longitud};
            await escribirDatos(3);
            await escribirDatos(4);
          });
        await interaction.reply({content: `Ticket generado con 칠xito.\nEl canal de contacto es: ${ch}`, ephemeral: true});
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          const reservaSheet = await sheet.addRows([
            { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Usuario contactado: ${userFetch.displayName} -> (${userFetch.id}).`, Reason: `${contenido}`}
          ]); 
        }catch(error){
          console.log(error)
        }
      });

    } catch (error){
      interaction.reply({content: `Se ha producido un error ${error}`, ephemeral: true})
    }
  } else if(interaction.commandName === 'cerrarticket'){
    if(!dbServeraUserEscribir[interaction.channel.id])
      return interaction.reply({content: `El canal no es de un ticket`, ephemeral: true});
    try{
      const guild = await client.guilds.resolve(guildID);
      const contenidoLogs = await guild.channels.resolve(logsTicket);
      const user = await client.users.fetch(dbServeraUserEscribir[interaction.channel.id].idUser);
      const fetched = await interaction.channel.messages.fetch().then(async messages => {// .messages.fetch o fetchMessages
        const salida = messages.map(m => `${new Date(m.createdAt).toLocaleString('en-US')} - ${m.author.tag}: ${m.attachments.size > 0 ? m.attachments.first().proxyURL : m.content}`).reverse().join('\n');
       // console.log('Salida \n' + salida); //Buffer.from(salida)
        const attachment = new AttachmentBuilder(Buffer.from(salida), {name: 'logsSoporte.txt', description: 'Logs del chat' }); /*, 'logsSoporte.txt'*/
        /*new AttachmentBuilder('C:\Users\Desktop\discord', { name: 'ticket.png' }) */
        await contenidoLogs.send({ content: `Ticket: ${user}`, files: [attachment] });
      });
      /*Borramos de la base de datos */
      
      const embedCerrarTicket = new EmbedBuilder()
      .setTitle('Ticket cerrado')
      .setColor('Red')
      .setDescription('Un staff ha cerrado su ticket de contacto')
      .setTimestamp()
      await user.send({embeds: [embedCerrarTicket]});
      
      await delete dbUseraServerEscribir[dbServeraUserEscribir[interaction.channel.id].idUser];
      await delete dbServeraUserEscribir[interaction.channel.id];
      await escribirDatos(4);
      await escribirDatos(3);
       /*Borramos el canal de texto */
      await interaction.channel.delete();
      
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      await canalLogs.send(`a`);
      const embedCloseTicket = new EmbedBuilder()
      .setTitle(`Ticket cerrado`)
      .addFields({name: 'User', value:`${user.displayName} -> (${user.id})`},
                 {name: 'Staff', value: `${interaction.member.displayName}->(${interaction.member.id})`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedCloseTicket]});
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Ticket cerrado a ${user.displayName} -> (${user.id}).`, Reason: ` `}
        ]); 
      }catch(error){
        console.log(error)
      }
    }catch(error){
      interaction.reply({content: `Se ha producido un error. \n ${error}`, ephemeral: true})
    }
  } else if(interaction.commandName === 'bloquearuser'){
    try{
      const user = interaction.options.getUser('user');
      const userFetched = await client.users.fetch(user);
      const reason = interaction.options.getString('reason');
      if(userFetched.bot)
        return interaction.reply({content: `No se puede bloquear a un bot`, ephemeral: true})
      var userID = userFetched.id;
      var bloqueado = true;
      bloqueadosModmailEscribir[userID] = {bloqueado};
      await escribirDatos(5);
      await interaction.reply({content: `Usuario bloqueado con 칠xito.`});
      const guild = await client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedUnlocked = new EmbedBuilder()
      .setTitle(`Usuario bloqueado del modmail.`)
      .addFields({name: `Staff`, value: `${interaction.member.displayName} -> ${interaction.member.id}`},
                  {name: `Usuario afectado`, value: `${userFetched.displayName} -> ${userFetched.id}`},
                  {name: `Raz칩n`, value: reason}  
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedUnlocked]});
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Usuario baneado: ${userFetched.displayName} -> (${userFetched.id}).`, Reason: `${reason}`}
        ]); 
      }catch(error){
        console.log(error)
      }
    } catch(error){
      console.log(error);
    }
    
  } else if(interaction.commandName === 'editarmensajeticket'){
    /* Nota: Si se edita mucho un mensaje puede generar errores intentando el bot enviar un mensaje demiasado largo */
    const newcontent = interaction.options.getString('newcontent');
    const idMensaje = interaction.options.getString('idmensaje');
    if(dbServeraUserEscribir[interaction.channel.id].mensajesEnServer.indexOf(idMensaje)!=-1){
      var pos = dbServeraUserEscribir[interaction.channel.id].mensajesEnServer.indexOf(idMensaje);
      var arr = dbServeraUserEscribir[interaction.channel.id].mensajesEnUser;
      /*Caso en el que mensaje se ha encontrado en la database. */
      const user = await client.users.resolve(dbServeraUserEscribir[interaction.channel.id].idUser);
      await user.createDM();
      const mensajeUser =  await user.dmChannel.messages.fetch(arr[pos]);
      const mensajeServer = await interaction.channel.messages.fetch(idMensaje);
      await mensajeUser.edit(newcontent);
      await mensajeServer.edit(`Nuevo contenido editado:\n${newcontent}\nContenido antes de la edici칩n:\n${mensajeServer.content}`);
      await interaction.reply({content: 'Editado con 칠xito'})
      const guild = client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.resolve(canalLogsMd);
      const embedChange = new EmbedBuilder()
      .setTitle(`Mensaje en Modmail editado por parte del staff`)
      .addFields({name: 'User', value:`${message.author.displayName} -> (${message.author.id})`},
                 {name: 'Contenido anterior: (Puede ser null si el bot se apago y perdi칩 el cach칠)', value: `${message.content}`},
                 {name: 'Nuevo contenido:', value: `${newcontent}`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedChange]});
    } else {
      await interaction.reply('Mensaje no encontrado');
    }
  } else if(interaction.commandName === 'status'){
    await interaction.reply({content: `Implementaci칩n del bot:\n九 Reserva de mesas. \n九 Reaction Role.\n九 Modmail\n九 Sugerencias \n九 Tempchannels\n九Torneos\n낍 Stats`, ephemeral: true});
  } else if(interaction.commandName === 'desbloquearuser'){
    const user = interaction.options.getUser('user');
    const userFetched = await client.users.fetch(user);
    if(bloqueadosModmailEscribir[userFetched.id]){
      await delete bloqueadosModmailEscribir[userFetched.id];
      await escribirDatos(5);
      const guild = await client.guilds.resolve(guildID);
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      await interaction.reply({content: `Usuario desbloqueado con 칠xito`});
      const embedUnlocked = new EmbedBuilder()
      .setTitle(`Usuario desbloqueado del modmail.`)
      .addFields({name: `Staff`, value: `${interaction.member.displayName} -> ${interaction.member.id}`},
                 {name: `Usuario afectado`, value: `${userFetched.displayName} -> ${userFetched.id}`}  
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedUnlocked]});
      try{
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        const reservaSheet = await sheet.addRows([
          { Fecha: new Date(), Staff: `${interaction.member.displayName} -> (${interaction.member.id})`, Accion: `Usuario desbaneado: ${userFetched.displayName} -> (${userFetched.id}).`, Reason: ` `}
        ]); 
      }catch(error){
        console.log(error)
      }
    } else {
      interaction.reply({content: `El usuario <@!${userFetched.id}> no est치 bloqueado`, ephemeral: true});
    }
  }  /*Generar invite eterna a un servidor donde generes el comando*/
  else if(interaction.commandName === 'generarinvite'){
    const guildFetch = client.guilds.resolve(guildID);
    try{
      const ch = guildFetch.rulesChannel;
      await ch.createInvite({maxAge: 0, maxUses:0 });
      await interaction.reply({content:`Invite generado con 칠xito`, ephemeral: true});
    } catch(error){
      console.log(error);
      await interaction.reply({content: `Se ha producido un error ${error}`, ephemeral: true});
    }
  } else if(interaction.commandName === "reactionroleembeds"){
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(interaction.options.getChannel('canal').id);
    var embedColores = new EmbedBuilder()
    .setTitle(`游깯 A침ade un color a tu usuario 游깯`)
    .setAuthor({name: client.user.username, iconURL: client.user.displayAvatarURL()})
    .setColor('DarkOrange')
    .setDescription('游댮 \n ```\nRojo```\n游릭\n```Verde```\n游댯\n```\nAzul```\n游리\n```\nAmarillo```')
    .setFooter({ text: 'Reaction Role Colores', iconURL: client.user.bannerURL()});
    await ch.send({embeds: [embedColores]});
    var embedLevel = new EmbedBuilder()
    .setTitle(`游끱 Nivel aproximado de ping pong 游끱`)
    .setAuthor({name: client.user.username, iconURL: client.user.displayAvatarURL()})
    .setColor('DarkOrange')
    .setDescription('游뎊n ```Nuevo jugando``` \n 游댫\n ```Principiante``` \n 괦잺\n ```Intermedio``` \n 游끱\n ```Federado / Antiguo federado```')
    .setFooter({ text: 'Reaction Role Nivel', iconURL: interaction.guild.iconURL()});
    await ch.send({embeds: [embedLevel]});
    await interaction.reply({content: `Ok`, ephemeral: true});

  } /* Sugerencias */
  else if(interaction.commandName === 'sugerir'){
    const contenido = interaction.options.getString('contenido');
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(canalSugerencias);
    if(interaction.options.getAttachment('adjunto')){
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setImage(interaction.options.getAttachment('adjunto').url)
      .setTimestamp()
      await ch.send({embeds: [embedSugerencia]}).then(async msg =>{
        await msg.react('九');
        await msg.react('游삔');
        await msg.react('仇');
        var user = interaction.member.id;
        var imagen = interaction.options.getAttachment('adjunto').url;
        dbSugerenciasEscribir[msg.id] = {user,contenido, imagen};
        await escribirDatos(7);
      });
    } else {
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setTimestamp()
      await ch.send({embeds: [embedSugerencia]}).then(async msg =>{
        await msg.react('九');
        await msg.react('游삔');
        await msg.react('仇');
        var user = interaction.member.id;
        imagen = null;
        dbSugerenciasEscribir[msg.id] = {user, contenido, imagen};
        await escribirDatos(7);
      });
    }
    await interaction.reply("Sugerencia realizada con 칠xito");
  } else if(interaction.commandName === 'sugerenciaimplementada'){
    var idSugerencia = interaction.options.getString('idsugerencia');
    if(!dbSugerenciasEscribir[idSugerencia]) return interaction.reply({content: 'La sugerencia no existe', ephemeral: true});
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(canalSugerencias); 
    const msj = await ch.messages.fetch(idSugerencia);
    await msj.delete();
    const chImpl =  await guildFetch.channels.resolve(sugerenciasImpl);
    contenido = dbSugerenciasEscribir[idSugerencia].contenido;
    if(dbSugerenciasEscribir[idSugerencia].imagen != null){
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setImage(dbSugerenciasEscribir[idSugerencia].imagen )
      .setTimestamp()
      await chImpl.send({embeds: [embedSugerencia]});
    } else {
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Green')
      .setTimestamp()
      await chImpl.send({embeds: [embedSugerencia]});
    }
    delete dbSugerenciasEscribir[idSugerencia];
    await escribirDatos(7);
    await interaction.reply("Sugerencia actualizada con 칠xito.")
  } else if(interaction.commandName === 'denegarsugerencia'){
    var idSugerencia = await interaction.options.getString('idsugerencia');
    if(!dbSugerenciasEscribir[idSugerencia]) return interaction.reply({content: 'La sugerencia no existe', ephemeral: true});
    const reason = await interaction.options.getString('reason');
    const guildFetch = client.guilds.resolve(guildID);
    const ch = await guildFetch.channels.fetch(canalSugerencias); 
    const msj = await ch.messages.fetch(idSugerencia);
    await msj.delete();
    const chDeneg =  await guildFetch.channels.resolve(sugDeneg);
    contenido = dbSugerenciasEscribir[idSugerencia].contenido;
    if(dbSugerenciasEscribir[idSugerencia].imagen != null){
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .addFields({name: 'Reason', value: '```' + reason + '```'})
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Red')
      .setImage(dbSugerenciasEscribir[idSugerencia].imagen )
      .setTimestamp()
      await chDeneg.send({embeds: [embedSugerencia]});
    } else {
      var embedSugerencia =  new EmbedBuilder()
      .setTitle(`**Sugerencias**`)
      .setAuthor({ name: interaction.member.displayName})
      .setDescription('Contenido de la sugerencia:\n```\n' + contenido + '\n```')
      .addFields({name: 'Reason', value: '```' + reason + '```'})
      .setThumbnail(interaction.guild.displayAvatarURL)
      .setColor('Red')
      .setTimestamp()
      await chDeneg.send({embeds: [embedSugerencia]});
    }
    delete dbSugerenciasEscribir[idSugerencia];
    await escribirDatos(7);
    await interaction.reply("Sugerencia actualizada con 칠xito.")
  } /* Informaci칩n sobre otros bots */
  else if(interaction.commandName === 'musicbot'){
    var embedMusicBot = new EmbedBuilder()
    .setTitle('Informaci칩n b치sica sobre el bot de m칰sica')
    .setAuthor({name: 'Jockie Music (1)#6951', iconURL: 'https://www.jockiemusic.com/assets/imgs/render.png'})
    .setThumbnail(interaction.guild.displayAvatarURL)
    .setColor('DarkGold')
    .setDescription('El bot solo funcionar치 en el canal de voz: <#1188501314892742757>')
    .addFields({name: '**m!play [cancion]**', value: 'A침ades una canci칩n a la lista de reproducci칩n o empieza a sonar esa canci칩n.'}, 
               {name: '**m!stop**', value: 'Paras la m칰sica y el bot abandona el canal de voz.'},
               {name: '**m!np**', value: 'Muestras informaci칩n sobre la cancion que suena actualmente'},
               {name: '**m!queue**', value: 'Muestras la lista de reproducci칩n del bot'})
    .setFooter({text: 'Esta no es informaci칩n oficial, simplemente es un muy peque침o resumen.'})
    await interaction.reply({ephemeral: true, content: 'Ok'});
    await interaction.channel.send({embeds: [embedMusicBot]});

  } /*Comando say*/
  else if (interaction.commandName === 'say'){
    const contentSay = interaction.options.getString('content');
    await interaction.channel.send(contentSay);
    await interaction.reply({content: 'ok', ephemeral: true});
  } /*Eventos de discord crear */
  else if (interaction.commandName === 'crearevento'){
    const guildFetch = client.guilds.resolve(guildID);
      const titulo = interaction.options.getString('titulo');
      const descripcion = interaction.options.getString('descripcion');
      var ub = interaction.options.getString('location');
      ub = (ub == null) ? 'Escuela T칠cnica Superior de Ingenieros Inform치ticos de la Universidad Polit칠cnica de Madrid' : ub;
      var fechaInicio = interaction.options.getString('fechainicio');
      var fechafin = interaction.options.getString('fechafin');
      var urlEvento;
      if(!verificarFecha(fechaInicio) || !verificarFecha(fechafin))
        return interaction.reply({content: 'Fechas en formato incorrecto, verifica que las fechas est치n en formato dd/m', ephemeral: true});
      arrFechaInicio = pasarAFecha(fechaInicio);
      arrFechaFin = pasarAFecha(fechafin);
      var fechaHoy = new Date();
      if (arrFechaInicio[1] < fechaHoy.getMonth() || (arrFechaInicio[1] === fechaHoy.getMonth() && arrFechaInicio[0] < fechaHoy.getDate())) {
        /* el evento es para el a침o que viene */
        fechaInicio = new Date(arrFechaInicio[1]+"/"+arrFechaInicio[0]+"/"+(fechaHoy.getFullYear()+1));
      } else {
        /*El evento es para este a침o */
        fechaInicio = new Date(arrFechaInicio[1]+"/"+arrFechaInicio[0]+"/"+(fechaHoy.getFullYear()));
      }
      if (arrFechaFin[1] < fechaHoy.getMonth() || (arrFechaFin[1] === fechaHoy.getMonth() && arrFechaFin[0] < fechaHoy.getDate())) {
        fechafin = new Date(arrFechaFin[1]+"/"+arrFechaFin[0]+"/"+(fechaHoy.getFullYear()+1));
      } else {
        fechafin = new Date(arrFechaFin[1]+"/"+arrFechaFin[0]+"/"+(fechaHoy.getFullYear()));
      }
      await guildFetch.scheduledEvents.create({
        name: titulo,
        description: descripcion,
        scheduledStartTime: fechaInicio,
        scheduledEndTime: fechafin,
        privacyLevel: 2,
        entityType: 3,
        entityMetadata: {
          location: ub,
        },
        reason: 'Creaci칩n de evento por parte de ' + interaction.member.id,
      });
    const ch = await interaction.guild.channels.resolve(canalEventos);
    const opciones = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    var embedNews = new EmbedBuilder()

    .setTitle('游닊 **NUEVO EVENTO** 游닊')
    .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL(), url: inviteServer})
    .setThumbnail(interaction.guild.iconURL())
    .setColor('DarkRed')
    .addFields({name: 'Nombre del evento: ', value: titulo},
               {name: 'Descripci칩n del evento:', value: descripcion},
               {name: 'Fecha de inicio: ', value: ' ' + fechaInicio.toLocaleDateString(undefined, opciones)},
               {name: 'Fecha de finalizaci칩n: ', value: ' ' + fechaInicio.toLocaleDateString(undefined, opciones)},
               {name: 'Ubicaci칩n: ', value: ub},
               {name: 'Invite del servidor de discord: ', value: `[Pulsa aqu칤](${inviteServer})`}
              )
    .setTimestamp()
    .setFooter({text: interaction.guild.name, iconURL: client.user.displayAvatarURL()})
    await ch.send({embeds: [embedNews]})
    interaction.reply('Todo ok');
        
  } /* Tempchannels */
  else if (interaction.commandName === 'creartempchannels'){
    const canal = interaction.options.getChannel('canal');
    if(canal.type != 2)
      return interaction.reply({content: 'Debes indicar un canal de voz', ephemeral: true});
    var cantidadUser = (interaction.options.getInteger('cantidaduser') == null) ? canal.userLimit : interaction.options.getInteger('cantidaduser');
    if(cantidadUser <0)
      return interaction.reply({content: 'Cantidad de usuarios incorrecta', ephemeral: true});
    cantidadUser = (cantidadUser >=100) ? 0: cantidadUser; /* Establecemos a infinito la cantidad de user factibles */
    /* Debemos establecer la base de datos.
      Tambi칠n debemos establecer por un booleano si este canal se puede borrar cuando est치 vaci칩 o no, en este caso no.
      La key sera el canal y tendr치 min un atr de si es borrable
    */
    borrable = false;
    nombre = canal.name;
    dbTempchanelsEscribir[canal.id] = {borrable, cantidadUser, nombre};
    await escribirDatos(8);
    await interaction.reply('Canal establecido con 칠xito');
  } else if(interaction.commandName === 'enviarfaq'){
    // Imagen de bots auxiliares

    const canal = await interaction.options.getChannel('canal');
    const opcion = await interaction.options.getInteger('opcion');
      if(opcion == 1){
        var embedMusicBot = new EmbedBuilder()
        .setTitle('Informaci칩n b치sica sobre el bot de m칰sica')
        .setAuthor({name: 'Jockie Music (1)#6951', iconURL: 'https://www.jockiemusic.com/assets/imgs/render.png'})
        .setThumbnail(interaction.guild.displayAvatarURL)
        .setColor('DarkGold')
        .setDescription('El bot solo funcionar치 en el canal de voz: <#1188501314892742757>')
        .addFields({name: '**m!play [cancion]**', value: 'A침ades una canci칩n a la lista de reproducci칩n o empieza a sonar esa canci칩n.'}, 
                  {name: '**m!stop**', value: 'Paras la m칰sica y el bot abandona el canal de voz.'},
                  {name: '**m!np**', value: 'Muestras informaci칩n sobre la cancion que suena actualmente'},
                  {name: '**m!queue**', value: 'Muestras la lista de reproducci칩n del bot'})
        .setFooter({text: 'Esta no es informaci칩n oficial, simplemente es un muy peque침o resumen.'})
        await canal.send({embeds: [embedMusicBot]});
        // Imagen de tempchannel
        var embedTempchannels = new EmbedBuilder()
        .setTitle('Informaci칩n sobre Tempchannel')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setColor('DarkGold')
        .setDescription('Todos los canales de voz pertenecientes a la categor칤a: <#1188827698987016252>, generan de manera autom치tica un canal en la categor칤a: <#' + parentTempChannels + '>.\nCada canal genera uno nuevo para un n칰mero determinado de usuarios.')
        .setFooter({text: 'Club ping pong tempchannels', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedTempchannels]})
        //Imagen Sugerencias
        var embedSugerencias = new EmbedBuilder()
        .setTitle('Informaci칩n sobre las sugerencias')
        .setColor('DarkGold')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription('Los par치metros obligatorios se denotan con **[]** y los opcionales con **()** ')
        .addFields({name: '**/sugerir [sugerencia] (adjunto)**', value: 'Env칤as una sugerencia.'})
        .setFooter({text: 'Sugerencias Club Ping Pong', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedSugerencias]});

        // Imagen de reservas 

        var embedReservas = new EmbedBuilder()
        .setTitle('Reserva de mesas')
        .setColor('DarkGold')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription('Los par치metros obligatorios se denotan con **[]** y los opcionales con **()** \nPuedes ver en tiempo real las reservas en este [google sheet](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)')
        .addFields({name: '**/reservamesa [dd/mm] [hh:mm] [hh:mm] (n_mesa)**', value: 'El primer par치metro es la fecha de la reserva, el segundo la hora de inicio, el tercero la hora de finalizaci칩n y el cuarto, opcional, el n칰mero de la mesa.' },
                  {name: '**/mostrarreservas [dd/mm]**', value: 'Muestras las reservas en una determinada fecha, las puedes ver en tiempo real en este [google sheet](https://docs.google.com/spreadsheets/d/1P5DxwHtz61GoMAX_iMn_OK1gc__uX4rBHTTpI9Tc-HA/edit?usp=sharing)'},
                  {name: '**/cancelarreserva [dd/mm]**', value: 'Cancelas la reserva que tienes en una determinada fecha.'},
                  {name: 'Requisitos', value: 'Puedes reservar como m치ximo una fecha, con una antelaci칩n de 6 meses.'}      
                  )
        .setFooter({text: 'Reserva de mesas', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedReservas]});
        //Imagen torneos

        var embedTorneos = new EmbedBuilder()
        .setTitle('Participaci칩n en torneos')
        .setColor('DarkGold')
        .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
        .setDescription('Hay dos modalidades de torneos:\n- Individual.\n- Parejas\nLos par치metros obligatorios se denotan con **[]** y los opcionales con **()**')
        .addFields({name: '**/torneo apuntarse individual [nombreTorneo] [correoinstitucional]**', value: 'Te apuntas a un torneo individual'},
                   {name: '**/torneo desapuntarse individual [nombreTorneo]**', value: 'Te desapuntas de un torneo individual'},
                   {name: '**/torneo apuntarse parejas [nombreTorneo] [correoinstitucional] (pareja) (correoparejainstitucional)**', value: 'Te apuntas a un torneo por parejas, en caso de no tener pareja, te intentaremos buscar una.\n- En caso de tener pareja, tambi칠n debes proporcionar su correo institucional para inscribirte con 칠l/ella.'},
                   {name: '**/torneo desapuntarse parejas [nombreTorneo]**', value: 'Te desapuntas solo a ti del torneo por parejas'}
        )
        .setFooter({text: 'Torneos', iconURL: interaction.guild.iconURL()})
        await canal.send({embeds: [embedTorneos]});

      }else if (opcion == 2){
          var embedModmail = new EmbedBuilder()
          .setTitle('Opciones de comandos modmail')
          .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
          .setColor('DarkGold')
          .setThumbnail(interaction.guild.displayAvatarURL)
          .setDescription('Los **[]** son par치metros obligatorios y los **()** son par치metros opcionales\n[쮺칩mo obtengo el id de un mensaje?](https://support.discord.com/hc/es/articles/206346498--D%C3%B3nde-puedo-encontrar-mi-ID-de-usuario-servidor-mensaje-)')
          .addFields({name: '**/reply [contenido] (adjunto)**', value: 'El contenido es el mensaje que recibe el user, el adjunto, opcional, es algo que quieres enviar al usuario, las imagenes enviadas no se pueden editar'},
                     {name: '**/editarmensajeticket [idMensaje] [nuevoContenido] **', value: 'Editas un mensaje que has enviado al usuario para ello necesitas la id del mensaje. '},
                     {name: '**/cerrarticket**', value: 'Cierras el ticket abierto de un usuario.'},
                     {name: '**/bloquearuser [usuario] [raz칩n]**', value: 'Bloqueas a un usuario con su razon correspondiente.'},
                     {name: '**/desbloquearuser [user] **', value: 'Desbloqueas a un usuario del uso del bot.'},
                     {name: '**/sugerenciaimplementada [idSugerencia]**', value: 'Marcas como aprobada una sugerencia.'},
                     {name: '**/denegarsugerencia [idSugerencia] [razon]**', value: 'Deniegas una sugerencia con su correspondiente raz칩n'},
                     {name: '**/crearevento [titulo] [descripcion] [fechainicio] [fechafin] (location)**', value: 'Creas un evento con un t칤tulo determinado, con una descripcion, cono una fecha de inicio y fin, la localizaci칩n por defecto es la facultad'},
                     {name: '**/establecerdbtorneo [tipo] [nombre]**', value: 'Creas un torneo, el tipo 0: Individual ripo:1 Parejas. \n Nombre es el nombre del torneo, por favor usar una 칰nica palabra como nombre del torneo a ser posible.'},
                     {name: '**/finalizarplazoinscripcion [nombre]**', value: 'Finalizas el plazo de inscripci칩n para el torneo con un nombre determinado.'}
                    )
          .setFooter({text: 'Modmail Club Ping Pong', iconURL: interaction.guild.iconURL()})
          await canal.send({embeds: [embedModmail]});
      }
      await interaction.reply('Ok');
  } /*reglas */
  else if(interaction.commandName  === 'reglas'){
    const ch = await interaction.options.getChannel('channel');
    if(ch.type != 0) return interaction.reply({content: 'No es un canal de texto', ephemeral: true});
    try{
      await ch.createWebhook({
        name: 'Reglas Club Ping Pong',
        avatar: client.user.displayAvatarURL(),
        reason: 'Webhook de reglas del servidor'
      }).then(async webhook =>{
        await webhook.send('Bienvenido/a al servidor de Discord del club de tenis de mesa de la facultad. Este es un lugar para hablar sobre el tenis de mesa , compartir consejos, organizar partidas y hacer amigos. Para que todos podamos disfrutar de este espacio, te pedimos que sigas estas normas:\n\n- S칠 respetuoso/a con los dem치s miembros. No insultes, amenaces, acoses o discrimines a nadie por su g칠nero, orientaci칩n sexual, raza, religi칩n, edad, nacionalidad o nivel de juego.\n- No compartas contenido ilegal, violento, pornogr치fico, ofensivo o que incite al odio. Tampoco hagas spam, publicidad o autopromoci칩n sin permiso de los administradores.\n- Usa los canales adecuados para cada tema. No desv칤es la conversaci칩n ni interrumpas a los dem치s. Si quieres hablar de algo que no est치 relacionado con el tenis de mesa, usa el canal <#1190035656408313927>.\n- La normativa oficial del tenis de mesa lo puedes encontrar en <#1190311360563773480>, si tienes alguna duda con respecto a las mismas puedes hac칠rnosla saber en <#1190313214026711130>.\n- Respeta las decisiones de los administradores y moderadores. Ellos est치n para mantener el orden y la armon칤a en el servidor. Si tienes alguna duda o queja, puedes contactar con ellos por mensaje privado al bot del club .\n- Si tienes alguna sugerencia no dudes en hacerla con **/sugerir**.\n- Divi칠rtete y disfruta del tenis de mesa. Recuerda que este es un espacio para compartir nuestra afici칩n, aprender unos de otros y pasar un buen rato.\n\nEl incumplimiento de estas normas puede resultar en una advertencia, una expulsi칩n temporal o permanente del servidor, seg칰n la gravedad de la falta.\nGracias por tu colaboraci칩n y esperamos que te lo pases bien en nuestro servidor.\n\nInvite del servidor: \n' + inviteServer);
        await webhook.delete();
      });
      await interaction.reply('Ok');
    }catch (error){
      interaction.reply("Error: \n" + error);
    }
  } /* Reglamento */
  else if(interaction.commandName === 'reglamentoindividual'){
    const ch = await interaction.options.getChannel('channel');
    if(ch.type != 0) return interaction.reply({content: 'No es un canal de texto', ephemeral: true});
    try{
      await ch.createWebhook({
        name: 'Reglamento Individual',
        avatar: client.user.displayAvatarURL(),
        reason: 'Webhook de reglas del servidor'
      }).then(async webhook =>{
        await webhook.send('***REGLAMENTO OFICIAL PING PONG INDIVIDUAL***');
        await webhook.send('**SERVICIO**:\n- Se comenzar치 con la pelota sobre la palma, de manera que sea claramente visible.\n- A la hora de sacar, se deber치 lanzar la pelota como m칤nimo 16 cm verticalmente, para luego, cuando descienda golpearla. En individual no es necesario sacar en diagonal, la pelota podr치 aterrizar en cualquier lado del otro campo. El saque deber치 realizarse por encima de la altura de la mesa, y detr치s de ella.\n\n- Si al realizar un servicio correcto, la pelota toca la red y luego bota en el campo enemigo, se deber치 repetir el saque. No es media, como en el tenis, s칩lo se tendr치 un intento m치s (a menos que se vuelva a tocar la red).\n- Adem치s, si se realiza un servicio sin que el otro jugador est칠 preparado, tambi칠n se repetir치 sin que nadie anote punto.');
        await webhook.send('**REPARTO DEL SERVICIO**:\n- El derecho a elegir el orden inicial de servir, recibir o lado de la mesa ser치 decidido por sorteo, y el ganador puede elegir servir o recibir primero, o empezar en un determinado lado de la mesa.\n- Cuando un jugador ha elegido servir o recibir primero, o empezar en un lado determinado, el otro jugador o pareja tendr치 la otra elecci칩n.\n- Despu칠s de cada 2 tantos anotados, el receptor o pareja receptora pasar치 a ser el servidor o pareja servidora, y as칤 hasta el final del juego, a menos que ambos jugadores hayan anotado 10 tantos. En estos 칰ltimos casos, el orden del servicio y de la recepci칩n ser치 el mismo, pero cada jugador servir치 tan s칩lo un tanto alternativamente.');
        await webhook.send('**DEVOLUCI칍N**:\n- Tras el servicio se jugar치 de manera normal, devolviendo la pelota siempre despu칠s de que bote en tu campo.');
        await webhook.send('**TANTOS**:\nUn jugador anotar치 un tanto:\n- Si un oponente no hace un servicio correcto. \n- Si un oponente no hace una devoluci칩n correcta.\n- S칤, tras haber realizado un servicio o una devoluci칩n, la pelota toca cualquier cosa, excepto el conjunto de la red, antes de ser golpeada por un oponente.\n- Si la pelota pasa por encima de su campo o m치s all치 de su l칤nea de fondo sin haber tocado su campo, tras ser golpeada por un oponente.\n- Si la pelota, despu칠s de haber sido golpeada por un oponente, pasa a trav칠s de la red, o entre la red y los postes de 칠sta, o entre la red y la superficie de juego.\n- Si un oponente obstruye la pelota.\n- Si un oponente golpea la pelota dos veces consecutivas de forma deliberada.\n- Si un oponente golpea la pelota con un lado de la hoja de la raqueta cuya superficie no cumple los requisitos exigidos.\n- Si un oponente, o cualquier cosa que 칠ste vista o lleve, mueve la superficie de juego.\n- Si un oponente, o cualquier cosa que 칠ste vista o lleve, toca el conjunto de la red.\n- Su oponente toca la mesa con cualquier mano antes de golpear la pelota.\n- El reposapi칠s o los pies del oponente tocan el suelo durante el juego.\n- Si se comete alguna infracci칩n del reglamento.' );
        await webhook.send('**GANAR UN SET**:\n- Ganar치 un set el jugador que primero alcance 11 tantos, excepto cuando ambos jugadores consigan 10 tantos; en este caso, ganar치 el juego el primer jugador o pareja que posteriormente obtenga 2 tantos de diferencia.');
        await webhook.send('**FAIR PLAY**:\n- Los jugadores y entrenadores u otros consejeros evitar치n comportamientos que puedan afectar injustamente a su oponente, ofender a los espectadores o desacreditar el deporte, como, por ejemplo, lenguaje inapropiado, romper deliberadamente la pelota o golpearla hacia fuera del 치rea de juego, dar patadas a la mesa o a las vallas y faltar al respeto a los oficiales de partidos.\n- Si se observa este comportamiento en alg칰n jugador de manera repetida ser치 descalificado del torneo.');
        await webhook.send('**쯈uieres m치s informaci칩n?**\n- Puedes consultarla [aqu칤](https://www.upm.es/sfs/Rectorado/Vicerrectorado%20de%20Alumnos/Deportes/Reglamento%20de%20Tenis%20de%20Mesa%2022-23.pdf).')
        await webhook.delete();
      });
      await interaction.reply('Ok');
    }catch (error){
      interaction.reply("Error: \n" + error);
    }
  } /*Torneo^^ */
  else if (interaction.commandName === 'torneo'){
    if(interaction.options.getSubcommandGroup() === 'apuntarse'){
      if(interaction.options.getSubcommand() === 'individual'){
        const nomTorneo = interaction.options.getString('nombre');
        const correo = interaction.options.getString('correo');
        if(verificarCorreoInstitucional(correo))
          return interaction.reply({content: 'Debe ser tu correo institucional', ephemeral: true});
        if(!dbTorneosParticipandoEscribir[nomTorneo])
          return interaction.reply({content: 'No existe el torneo', ephemeral: true});
        if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)!= -1)
          return interaction.reply({content: 'Ya est치s inscrito', ephemeral: true});
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          if(!sheet)
            return interaction.reply('Ese torneo no existe');
          const reservaSheet = await sheet.addRows([
          { User: `${interaction.member.displayName}`, UserId: interaction.member.id, Correo: correo }/* Datos salvados de los usuarios inscritos */
          ]);
          dbTorneosParticipandoEscribir[nomTorneo].participantes = anadirDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, interaction.member.id, dbTorneosParticipandoEscribir[nomTorneo].participantes.length);
          await escribirDatos(9);
        }catch(error){
          console.log(error)
          interaction.reply({content: 'Se ha producido un error con la inscripci칩n.', ephemeral: true});
        }
        try{
          var embedTorneoApuntadoIndividual = new EmbedBuilder()
          .setTitle('**Inscripci칩n en torneo individual**')
          .setColor('DarkGreen')
          .setThumbnail(interaction.guild.iconURL())
          .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
          .setDescription('Ha sido inscrito en el torneo individual de manera satisfactoria. \n- Torneo: ' + nomTorneo)
          .setTimestamp()
          await interaction.member.send({embeds: [embedTorneoApuntadoIndividual]});
        } catch( error){
          /* La 칰nica de las opciones es que el usuario no admita md del bot */
          var embedTorneoApuntadoIndividual = new EmbedBuilder()
          .setTitle('**Inscripci칩n en torneo individual**')
          .setColor('DarkGreen')
          .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
          .setDescription('Ha sido inscrito en el torneo individual de manera satisfactoria. \n- Torneo: ' + nomTorneo)
          .setTimestamp()
          await interaction.channel.send({embeds: [embedTorneoApuntadoIndividual]});
        }
        interaction.reply({content: 'Operaci칩n realizada con 칠xito.', ephemeral: true});
      } else if(interaction.options.getSubcommand() === 'parejas'){
        const nomTorneo = interaction.options.getString('nombre');
        const pareja = interaction.options.getUser('companero');
        const correo = interaction.options.getString('correo');
        const correoCompanero = interaction.options.getString('correocompanero');
        if(pareja!=null && correoCompanero == null)
          await interaction.reply({content: 'Debes introducir el correo institucional de tu compa침ero', ephemeral: true})
        if(pareja.bot)
          return interaction.reply({content: 'No puedes jugar con un bot', ephemeral: true});
        if(!dbTorneosParticipandoEscribir[nomTorneo])
          return interaction.reply({content: 'No existe el torneo', ephemeral: true});
        if(verificarCorreoInstitucional(correo))
          return interaction.reply({content: 'Debes introducir un correo institucional.', ephemeral: true});
        if(pareja != null && correoCompanero != null){
          if(verificarCorreoInstitucional(correoCompanero))
            return interaction.reply({content: 'Debes introducir un correo institucional.', ephemeral: true});
        }
        if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)!= -1)
          return interaction.reply({content: 'Ya est치s inscrito', ephemeral: true});
        try{
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          if(!sheet)
            return interaction.reply({content: 'Ese torneo no existe', ephemeral: true});
          const reservaSheet = await sheet.addRows([
          { User: `${interaction.member.displayName}`, Correo: correo , UserId: interaction.member.id, Companero: (pareja!=null)? pareja.displayName : '', CompaneroId: (pareja != null)? pareja.id:'', CorreoCompanero: (pareja!=null) ? correoCompanero: '' }/* Datos salvados de los usuarios inscritos */
          ]);
          dbTorneosParticipandoEscribir[nomTorneo].participantes = anadirDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, interaction.member.id, dbTorneosParticipandoEscribir[nomTorneo].participantes.length);
          await escribirDatos(9); 
          if(pareja!=null){
            dbTorneosParticipandoEscribir[nomTorneo].participantes = anadirDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, pareja.id, dbTorneosParticipandoEscribir[nomTorneo].participantes.length);
            await escribirDatos(9);
          }
          interaction.reply({content: 'Proceso realizado con 칠xito', ephemeral: true});   
          try{
            var embedInscrPar = new EmbedBuilder()
            .setTitle('**Inscripci칩n torneo en parejas**')
            .setColor('DarkGreen')
            .setDescription('Inscripci칩n satisfactoria en el torneo.\n- Comando ejecutado por: ' + interaction.member.displayName + '\n- Inscripci칩n en: ' + nomTorneo)
            .setThumbnail(interaction.guild.iconURL())
            .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
            .setTimestamp()
            await interaction.member.send({embeds: [embedInscrPar]});
            if(pareja !=null){
              await pareja.send({embeds: [embedInscrPar]});
            }
          } catch(error){
            var embedInscrPar = new EmbedBuilder()
            .setTitle('**Inscripci칩n torneo en parejas**')
            .setColor('DarkGreen')
            .setDescription('Inscripci칩n satisfactoria en el torneo.\n- Comando ejecutado por: ' + interaction.member.displayName + '\n- Inscripci칩n en: ' + nomTorneo)
            .setThumbnail(interaction.guild.iconURL())
            .setAuthor({name: client.user.displayName, iconURL: client.user.displayAvatarURL()})
            .setTimestamp()
            if(pareja!=null){
              await interaction.channel.send({content: `<@${pareja.id}>`, embeds: [embedInscrPar]});
            } else {
              await interaction.channel.send({embeds: [embedInscrPar]})
            }
          }
        
          
        }catch(error){
          console.log(error)
          interaction.reply({content: 'Se ha producido un error con la inscripci칩n.', ephemeral: true});
        }
      }
    } else  if(interaction.options.getSubcommandGroup() === 'desapuntarse'){  
      if(interaction.options.getSubcommand() === 'individual'){
        const nomTorneo = interaction.options.getString('nombre');
        if(!dbTorneosParticipandoEscribir[nomTorneo])
          return interaction.reply('No existe el torneo');
        if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)== -1)
          return interaction.reply('No estas inscrito');
        const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
        await doc.loadInfo();
        const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
        if(!sheet)
          return interaction.reply('Ese torneo no existe');
        const userBorrar = interaction.member.id;
        /* Vamos a intentar borrar por nombre. */
        await sheet.loadCells();
        // Encontrar y eliminar la fila
        const rows = sheet.rowCount;
        continuar = true;
        for (let i = 0; i < rows && continuar; i++) {
          const cell2 = sheet.getCell(i, 1)
          if (cell2.value == userBorrar) {
            sheet.clearRows({start: i+1, end: i+1});
            continuar = false;
          }
        } 
        dbTorneosParticipandoEscribir[nomTorneo].participantes = eliminarDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id), dbTorneosParticipandoEscribir[nomTorneo].participantes.length )
        await escribirDatos(9);
        interaction.reply('Operaci칩n realizada con 칠xito.');
      } else if(interaction.options.getSubcommand() === 'parejas') {
          const nomTorneo = interaction.options.getString('nombre');
          if(!dbTorneosParticipandoEscribir[nomTorneo])
            return interaction.reply('No existe el torneo');
          if(dbTorneosParticipandoEscribir[nomTorneo] && dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id)== -1)
            return interaction.reply('No estas inscrito');
          const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
          await doc.loadInfo();
          const sheet = await doc.sheetsByTitle[nomTorneo]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
          if(!sheet)
            return interaction.reply('Ese torneo no existe');
          const userBorrar = interaction.member.id;
          /* Vamos a intentar borrar por nombre. */
          await sheet.loadCells();
          // Encontrar y eliminar la fila
          const rows = sheet.rowCount;
          continuar = true;
          for (let i = 0; i < rows && continuar; i++) {
            const cellBuscandoOp1 = sheet.getCell(i, 1);
            const cellBuscandoOp2 = sheet.getCell(i, 4);
            if (cellBuscandoOp1.value == userBorrar) {
              console.log('Encontrado y esta persona hizo el comando');
              /* El que ejecut칩 la inscripci칩n se va */
              cellBuscandoOp1.value='';
              var cell1 = sheet.getCell(i, 0);
              var cell2 = sheet.getCell(i,2);
              cell1.value='';
              cellBuscandoOp1.save();
              cell1.save();
              cell2.value='';
              cell2.save();
              continuar = false;
            } else if (cellBuscandoOp2.value == userBorrar){
              console.log('Encontrado e hizo otra persona el comando');
              cellBuscandoOp2.value='';
              var cell1 = sheet.getCell(i,3);
              var cell2 = sheet.getCell(i,5);
              cell2.value='';
              cell2.save();
              cell1.value='';
              cellBuscandoOp2.save();
              cell1.save();
              continuar = false;
            }
          } 
          dbTorneosParticipandoEscribir[nomTorneo].participantes = eliminarDelArray(dbTorneosParticipandoEscribir[nomTorneo].participantes, dbTorneosParticipandoEscribir[nomTorneo].participantes.indexOf(interaction.member.id), dbTorneosParticipandoEscribir[nomTorneo].participantes.length )
          await escribirDatos(9);
          interaction.reply({content: 'Operaci칩n realizada con 칠xito.', ephemeral: true});
      }
    }
    
  } else if(interaction.commandName === 'establecerdbtorneo'){
    const tipo = interaction.options.getInteger('tipo');
    const nombre = interaction.options.getString('nombre');
    if(tipo === 0){
      const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
      const sheet = await doc.addSheet({ headerValues: ['User', 'UserId', 'Correo'] });
      await sheet.updateProperties({ title: nombre });
      await interaction.reply('Creado con exito');
      var participantes = new Array(0);
      dbTorneosParticipandoEscribir[nombre] = {participantes};
      await escribirDatos(9);
    } else if(tipo === 1){
      const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
      const sheet = await doc.addSheet({ headerValues: ['User', 'UserId','Correo', 'Companero', 'CompaneroId','CorreoCompanero'] });
      await sheet.updateProperties({ title: nombre });
      await interaction.reply('Creado con exito');
      var participantes = new Array(0);
      dbTorneosParticipandoEscribir[nombre] = {participantes};
      await escribirDatos(9);
    } else {
      interaction.reply('Opci칩n no contemplada, cancelado.');
    }
  } else if (interaction.commandName === 'finalizarplazoinscripcion'){
    const torneo = await interaction.options.getString('nombre');
    if(!dbTorneosParticipandoEscribir[torneo])
      return interaction.reply('El torneo no existe o ya fue finalizado el plazo de inscripci칩n');
    delete dbTorneosParticipandoEscribir[torneo];
    await escribirDatos(9);
    interaction.reply('Plazo de inscripci칩n finalizado con 칠xito para:\n- ' + torneo);
  }
  const guildFetch = client.guilds.resolve(guildID);
  const channelLogsSlash = guildFetch.channels.resolve(logComandos);
  var embedLogSlash =  new EmbedBuilder()
  .setTitle(`Nueva ejecuci칩n de comando`)
  .addFields({name: 'User', value: `${interaction.member.displayName} -> (${interaction.member.id})`},
             {name: `Comando:`, value: `${interaction.commandName}`}
            )
  .setColor('Default')
  .setTimestamp()
  await channelLogsSlash.send({embeds: [embedLogSlash]})

});

/*Modmail edici칩n de mensajes */

client.on('messageUpdate', async(oldMessage, newMessage)=>{
  try{
    if(oldMessage.partial) await oldMessage.fetch();
    if(newMessage.partial) await newMessage.fetch();
    if(!newMessage.author.bot &&!oldMessage.guild && dbUseraServerEscribir[newMessage.author.id].mensajesEnUser.indexOf(oldMessage.id)!= -1){
      /* Se debe cambiar  un mensaje de la database */
      const guild = await client.guilds.resolve(guildID);
      
      const channelGuild = await guild.channels.fetch(dbUseraServerEscribir[newMessage.author.id].idChannel);
      var pos = dbUseraServerEscribir[newMessage.author.id].mensajesEnUser.indexOf(newMessage.id);
      var arr = dbUseraServerEscribir[newMessage.author.id].mensajesEnServer;
      await channelGuild.messages.fetch(arr[pos]).then(async msg =>{
        await msg.edit(`**Mensaje editado**:\n${newMessage.content}\n**Mensaje anterior editado**: (Puede haber m치s verificar logs)\n${oldMessage.content}`);
      });
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedChange = new EmbedBuilder()
      .setTitle(`Mensaje en Modmail editado por parte del usuario`)
      .addFields({name: 'User', value:`${newMessage.author.displayName} -> (${newMessage.author.id})`},
                 {name: 'Contenido anterior: (Puede ser null si el bot se apago y perdi칩 el cach칠)', value: `${oldMessage.content}`},
                 {name: 'Nuevo contenido:', value: `${newMessage.content}`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedChange]});
    }
  }catch(error){
    console.log(error);
  }
});

/* Modmail se borran mensajes. */
client.on('messageDelete', async message=>{
  try{
    if(message.partial) await message.fetch();
    if( !message.guild && dbUseraServerEscribir[message.author.id].mensajesEnUser.indexOf(message.id)!= -1){
      /* Se borra un mensaje que est치 asociado en la database */
      const guild = await client.guilds.resolve(guildID);
      const channelGuild = await guild.channels.fetch(dbUseraServerEscribir[message.author.id].idChannel);
      var pos = dbUseraServerEscribir[message.author.id].mensajesEnUser.indexOf(message.id);
      var arr = dbUseraServerEscribir[message.author.id].mensajesEnServer;
      await channelGuild.messages.fetch(arr[pos]).then(async msg =>{
        await msg.edit(`**Mensaje borrado:**\n${message.content}`);
      });
      const canalLogs = await guild.channels.fetch(canalLogsMd);
      const embedDelete = new EmbedBuilder()
      .setTitle(`Mensaje en Modmail borrado por parte del usuario`)
      .addFields({name: 'User', value:`${message.author.displayName} -> (${message.author.id})`},
                 {name: 'Contenido:', value: `${message.content}`}
                )
      .setColor('DarkGrey')
      .setTimestamp()
      await canalLogs.send({embeds: [embedDelete]});
    } 
  }catch(error){
    console.log(error);
  }
});


/*  Reactions */

client.on('messageReactionAdd', async(messageReaction, user)=>{
  try{
    if (user.partial) await user.fetch();
    if(user.bot) return;
    if(messageReaction.partial) await messageReaction.fetch(); 
    var reactionID = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id; 
      if(dbReactionRoleEscribir[messageReaction.message.id]){
        if(dbReactionRoleEscribir[messageReaction.message.id].canalID == messageReaction.message.channel.id && (dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)!=-1)){
          /* La reacci칩n est치 en la database */
          const member = await messageReaction.message.guild.members.fetch(user.id);
          // Asignamos el role por id.
          await member.roles.add(dbReactionRoleEscribir[messageReaction.message.id].role[dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)]);
        }
    } else if (!messageReaction.message.guild && dbUseraServerEscribir[user.id]) {
      try{
        const guild = await client.guilds.resolve(guildID);
        const channel = await guild.channels.resolve(dbUseraServerEscribir[user.id].idChannel);
        var pos = dbUseraServerEscribir[user.id].mensajesEnUser.indexOf(messageReaction.message.id);
        var mensajeIDServer = dbUseraServerEscribir[user.id].mensajesEnServer;
        const mensaje = await channel.messages.fetch(mensajeIDServer[pos]);
        await mensaje.react(messageReaction.emoji);
      }catch(error){
        console.log(error);
      }

    } else if(messageReaction.message.guild && dbServeraUserEscribir[messageReaction.message.channel.id]){
      const user = await client.users.fetch(dbServeraUserEscribir[messageReaction.message.channel.id].idUser);
      var pos = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnServer.indexOf(messageReaction.message.id);
      console.log(pos);
      var arr = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnUser;
      const mensaje = await user.dmChannel.messages.fetch(arr[pos]);
      await mensaje.react(messageReaction.emoji);
    }/* Reacciones para sugerencias */
    else if(dbSugerenciasEscribir[messageReaction.message.id]){
      /* Significa que el mensaje est치 en la base de datos de sugerencias */
      // Debo sacar la cantidad de reacciones por tipo de reacciones, suponiendo que solo va a  haber tres.
      //console.log(messageReaction.message.reactions.resolve('九').count)
      var contadorOk = messageReaction.message.reactions.resolve('九').count -1;
      var contadorIdk = messageReaction.message.reactions.resolve('游삔').count -1;
      var contadorX = messageReaction.message.reactions.resolve('仇').count -1;
      var contadorVotacionesTotales = (contadorOk+contadorIdk+contadorX);
      const mensaje = messageReaction.message;
      const user = client.users.resolve(dbSugerenciasEscribir[mensaje.id].user);
      if(dbSugerenciasEscribir[mensaje.id].imagen != null){
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setImage(dbSugerenciasEscribir[mensaje.id].imagen)
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]})
      } else {
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]});
      }
    }
  } catch(error){
    console.log(error);
  }
});


client.on('messageReactionRemove', async(messageReaction, user)=>{
  try{
    if (user.partial) await user.fetch();
    if(user.bot) return;
    if(messageReaction.partial) await messageReaction.fetch(); 
    var reactionID = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id; 
    if(dbReactionRoleEscribir[messageReaction.message.id]){
      if(dbReactionRoleEscribir[messageReaction.message.id] && dbReactionRoleEscribir[messageReaction.message.id].canalID == messageReaction.message.channel.id && (dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)!=-1)){
        /* La reacci칩n est치 en la database */
        const member = await messageReaction.message.guild.members.fetch(user.id);
        // Asignamos el role por id.
        await member.
        roles.remove(dbReactionRoleEscribir[messageReaction.message.id].role[dbReactionRoleEscribir[messageReaction.message.id].emojis.indexOf(reactionID)]   );
      }
    }  else if (!messageReaction.message.guild && dbUseraServerEscribir[user.id]) {
      try{
        const guild = await client.guilds.resolve(guildID);
        const channel = await guild.channels.resolve(dbUseraServerEscribir[user.id].idChannel);
        var pos = dbUseraServerEscribir[user.id].mensajesEnUser.indexOf(messageReaction.message.id);
        var mensajeIDServer = dbUseraServerEscribir[user.id].mensajesEnServer;
        const mensaje = await channel.messages.fetch(mensajeIDServer[pos]);
        var aBuscar = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id;
        await mensaje.reactions.resolve(aBuscar).remove();
      }catch(error){
        console.log(error);
      }

    }  else if(messageReaction.message.guild && dbServeraUserEscribir[messageReaction.message.channel.id]){
      // Da error falta por implementar
      const user = await client.users.fetch(dbServeraUserEscribir[messageReaction.message.channel.id].idUser);
      var pos = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnServer.indexOf(messageReaction.message.id);
      var arr = dbServeraUserEscribir[messageReaction.message.channel.id].mensajesEnUser;
      const mensaje = await user.dmChannel.messages.fetch(arr[pos]);
      var aBuscar = (messageReaction.emoji.id == null) ? messageReaction.emoji.name : messageReaction.emoji.id;
      await mensaje.reactions.resolve(aBuscar).remove(client.user);
    }/* Reacciones para sugerencias */
    else if(dbSugerenciasEscribir[messageReaction.message.id]){
      /* Significa que el mensaje est치 en la base de datos de sugerencias */
      // Debo sacar la cantidad de reacciones por tipo de reacciones, suponiendo que solo va a  haber tres.
      //console.log(messageReaction.message.reactions.resolve('九').count)
      
      var contadorOk = messageReaction.message.reactions.resolve('九').count -1;
      var contadorIdk = messageReaction.message.reactions.resolve('游삔').count -1;
      var contadorX = messageReaction.message.reactions.resolve('仇').count -1;
      contadorVotacionesTotales = (contadorOk + contadorIdk + contadorX);
      const mensaje = messageReaction.message;
      const user = client.users.resolve(dbSugerenciasEscribir[mensaje.id].user);
      if(dbSugerenciasEscribir[mensaje.id].imagen != null){
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setImage(dbSugerenciasEscribir[mensaje.id].imagen)
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]})
      } else {
        var embedSugerencia = new EmbedBuilder()
        .setTitle(`**Sugerencias**`)
        .setAuthor({ name: user.displayName})
        .setDescription('Contenido de la sugerencia:\n```\n' + dbSugerenciasEscribir[mensaje.id].contenido + '\n```' + `\n ~ A favor: ${Math.round(contadorOk/contadorVotacionesTotales*100)}%\n ~ Idk: ${Math.round(contadorIdk/contadorVotacionesTotales*100)}%\n ~ En contra: ${Math.round(contadorX/contadorVotacionesTotales*100)}% `)
        .setThumbnail(mensaje.guild.displayAvatarURL)
        .setColor('Green')
        .setTimestamp()
        await mensaje.edit({embeds: [embedSugerencia]});
      }
    }
  } catch(error){
    console.log(error);
  }
});

/* Modmail */
client.on("messageCreate", async message => {

    try{
    if(message.partial)
      await message.fetch();
    if(message.author.bot && message.channel.type === 5 && message.channel.id === canalEventos){
      message.crosspost()
    }
    if(message.author.bot) return; 
    if(!message.guild && bloqueadosModmailEscribir[message.author.id])
      return message.reply('游 Est치 bloqueado del modmail')
    if(!message.guild){
      /* Caso del md para el modmail */
      const guild = await client.guilds.resolve(guildID);
      if(dbUseraServerEscribir[message.author.id]){
        /*Caso en el cual el usuario ya tiene un ticket de modmail abierto. */
        const ch = await guild.channels.resolve(dbUseraServerEscribir[message.author.id].idChannel);
        await ch.send(`**${message.author.displayName}**: \n<@&${idRoleSoporte}>`);
        var mensajeEnServer = await ch.send(message.content + "");
        var mensajeEnUsuario = message.id;
        if(message.attachments.size>0){
          message.attachments.forEach(async at=>{
            await ch.send(at.url);
          });
        }
        dbUseraServerEscribir[message.author.id].mensajesEnUser = anadirDelArray(dbUseraServerEscribir[message.author.id].mensajesEnUser, message.id, dbUseraServerEscribir[message.author.id].longitud);
        dbUseraServerEscribir[message.author.id].mensajesEnServer = anadirDelArray(dbUseraServerEscribir[message.author.id].mensajesEnServer, mensajeEnServer.id, dbUseraServerEscribir[message.author.id].longitud);
        dbUseraServerEscribir[message.author.id].longitud = dbUseraServerEscribir[message.author.id].longitud +1;
        dbServeraUserEscribir[ch.id].mensajesEnUser= dbUseraServerEscribir[message.author.id].mensajesEnUser;
        dbServeraUserEscribir[ch.id].mensajesEnServer = dbUseraServerEscribir[message.author.id].mensajesEnServer;
        dbServeraUserEscribir[ch.id].longitud = dbUseraServerEscribir[message.author.id].longitud;
        await escribirDatos(3);
        await escribirDatos(4);
        await message.react('九');
        await ch.setTopic(`Ticket pendiente de la respuesta del staff. \n 칔ltima interaccion ${new Date()}`);
      } else {
        const embedNuevoTicket = new EmbedBuilder()
        .setTitle('쯈uieres crear un ticket?')
        .setAuthor({name: client.user.displayName, avatarURL: client.user.displayAvatarURL})
        .setDescription('Un ticket es para hacer consultas a los moderadores y administridores del servidor.\nSi quieres ponerte en contacto reacciona con el emoji de a continuaci칩n. \nSi no ignora este mensaje.')
        .setColor('Yellow')
        .setTimestamp()
        await message.channel.send({embeds: [embedNuevoTicket]}).then(async msg =>{
          emoji = await client.emojis.resolveId(emojiAperturaTicket);
          await msg.react(emoji);
          const filter = (reaction, user) => {
            user.id === message.author.id && msg.id === reaction.message.id;
          };
          var salvado = false; // Salvaguarda para solo guardar un emoji por comando.
          const Collector = msg.createReactionCollector(filter, { time: 120000, max: 1 });
          Collector.on('collect', async reaction => {
            if(salvado) return;
            if(reaction.emoji.id == emojiAperturaTicket || reaction.emoji.name == emojiAperturaTicket){/*Depende del caso de que sea un emoji est치ndar o de un server */
              /* Debemos a침adir a la correspondiente database y crear un canal de texto en la categoria del servidor correspondiente. */
              await guild.channels.create({name: `ticket-${message.author.displayName}`, parent: categoriaTicketsID, topic: `Ticket pendiente de la respuesta del staff. \n 칔ltima interaccion ${new Date()}`}).then(async ch =>{
                //Establecemos los datos en la database.
                var idChannel = ch.id;
                var idUser = message.author.id;
                var mensajesEnUser = [message.id];
                var longitud = 1;
                await ch.send(`**${message.author.displayName}**: \n<@&${idRoleSoporte}>`);
                var primMsgServer = await ch.send(message.content + "");/* Le metemos un caracter invisible para evitar posibles errores de que solo haya un archivo. */
                var mensajesEnServer = [primMsgServer.id];
                dbUseraServerEscribir[message.author.id] = {idChannel, mensajesEnUser, mensajesEnServer, longitud};
                dbServeraUserEscribir[ch.id] = {idUser, mensajesEnUser, mensajesEnServer, longitud};
                await escribirDatos(3);
                await escribirDatos(4);
                if(message.attachments.size>0){
                  message.attachments.forEach(async at=>{
                    await ch.send(at.url);
                  });
                }
              });
              salvado = true;
              try{
                const doc = new GoogleSpreadsheet(idGoogleSheets, serviceAccountAuth);
                await doc.loadInfo();
                const sheet = await doc.sheetsByIndex[3]; // or use `doc.sheetsById[id]` or `doc.sheetsByTitle[title]`
                const reservaSheet = await sheet.addRows([
                  { Fecha: new Date(), Staff: ` `, Accion: `Contacto por modmail de parte de ${message.author.displayName}-> (${message.author.id})`, Reason: message.content}
                ]);
              }catch(error){
                console.log(error)
              }
            }
          });
        });


      }
    }
  }catch(error){
    console.log(error);
  }
});


/*Entra un nuevo miembro al servidor */
client.on('guildMemberAdd', async (member) =>{
  const guild = await client.guilds.resolve(guildID);
  const channelWelcome = await guild.channels.resolve(canalBienvenida);
});



/* TEMPCHANNELS */
client.on("voiceStateUpdate", async (oldState, newState) => {
  if(newState.channel != null && dbTempchanelsEscribir[newState.channel.id] && dbTempchanelsEscribir[newState.channel.id].borrable == false){
    /*Significa que es un canal el que crea tempchannel*/
    /* Debemos crear un canal de voz en un parent determinado y mover al usuario creador a su canal. */
    newState.guild.channels.create({name: `${dbTempchanelsEscribir[newState.channel.id].nombre}-${newState.member.displayName}`, parent: parentTempChannels, type: 2}).then(async ch =>{
      await ch.setUserLimit(dbTempchanelsEscribir[newState.channel.id].cantidadUser); /* Establecemos el l칤mite de usuarios del canal */
      await newState.setChannel(ch); /*Desplazamos al usuario al canal oportuno */
      borrable = true;
      creador = newState.member.id;
      dbTempchanelsEscribir[ch.id] = {borrable, creador}; /*No necesito salvar m치s datos que estos para saber que el canal se puede borrar.*/
      await escribirDatos(8);
    });
  } else if (oldState .channel!= undefined && dbTempchanelsEscribir[oldState.channel.id] && oldState.channel.members.size === 0 && dbTempchanelsEscribir[oldState.channel.id].borrable == true){
    /*Significa que debemos de borrar el canal*/
    var canal = oldState.channel.id;
    await oldState.channel.delete("Canal tempchannel de: " + dbTempchanelsEscribir[oldState.channel.id].creador);
    delete dbTempchanelsEscribir[canal];
    await escribirDatos(8);
  }

});



















// Log in to Discord with your client's token
client.login(token);





/*Clases auxiliares y funciones auxiliares para almacenamiento de datos en base de datos*/

function buscarMesa(horaInicio, horaFin, db){
  continuar = true;
  let i = 1;
  while(i <= numMesas && continuar){
    continuar = (verificarMesa(i, horaInicio, horaFin, db) == -1);
    i = i+1;
  }
  return (continuar == false) ? (i-1):-1;
}
function verificarMesa(mesa, horaInicio, horaFin, db){
  arrHorasInicio = db.arrayHoraInicio;
  arrHorasFin = db.arrayHoraFin;
  arrMesas = db.arrayMesas;
  disponible = true;
  /*De precondici칩n todos los arrays deben tener la misma longitud*/

  // Iterar sobre las reservas existentes en la misma fecha
  for (let i = 0; i < db.longitud && disponible; i++) {
    if ((seSolapan(horaInicio, horaFin, arrHorasInicio[i], arrHorasFin[i])) && mesa === arrMesas[i]) {
      /*Implica que hay solapamiento y las mesas que verificamos que son la misma mesa. */
      disponible = false;
    }
  }
  return (disponible == false) ? -1: mesa;
}
function escribirDatos(db){
  if(db === 1){
    fs.writeFile("./databases/reservas.json", JSON.stringify(dbReservasEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db === 2){
    fs.writeFile("./databases/reactionrole.json", JSON.stringify(dbReactionRoleEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db === 3){
    fs.writeFile("./databases/serverauser.json", JSON.stringify(dbServeraUserEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 4){
    fs.writeFile("./databases/useraserver.json", JSON.stringify(dbUseraServerEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 5){
    fs.writeFile("./databases/bloqueadosmodmail.json", JSON.stringify(bloqueadosModmailEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db ==6){
    fs.writeFile("./databases/reservashechasporuser.json", JSON.stringify(dbReservasHechasPorUserEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 7){
    fs.writeFile("./databases/sugerencias.json", JSON.stringify(dbSugerenciasEscribir, null, "  "), function(err) {
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 8){
    fs.writeFile("./databases/tempchannels.json", JSON.stringify(dbTempchanelsEscribir, null, " "), function(err){
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  } else if(db == 9){
    fs.writeFile("./databases/torneosparticipando.json", JSON.stringify(dbTorneosParticipandoEscribir, null, " "), function(err){
      if (err) throw TypeError("Un error inesperado ha ocurrido!");
    });
  }
}
function anadirDelArray(arrayOriginal, nuevoDato, longitudArray){
  arrayRes = new Array(longitudArray +1);
  let i = 0;
  while(i < longitudArray){
    arrayRes[i] = arrayOriginal[i];
    i = i+1;
  }
  arrayRes[longitudArray] = nuevoDato;
  return arrayRes;
}
function eliminarDelArray(arrayOriginal, pos, longitudArray){
  arrayRes = new Array(longitudArray-1);
  j = 0;
  for(i = 0; i < longitudArray; i++){
    if(i!=pos){
      arrayRes[j] = arrayOriginal[i];
      j++; 
    }
  }
  return arrayRes;
}
function verificarHoras(hora){
  /* Hacemos un try catch ya que pueden meter un caracter que no puede hacerse un parseInt */
  try{
    if((parseInt(hora.charAt(0))>=0 && parseInt(hora.charAt(0))<2) && (hora.charAt(2) == ':') && (parseInt(hora.charAt(3))>=0 && parseInt(hora.charAt(3))<6) && (parseInt(hora.charAt(4))>= 0))
      return true;
    return false;
    /*En formato 24 horas, el horario de la facultad es m칤nimo de 0 que dudo que vaya alguien a las ocho ha jugar al pin pon hasta las las 20 */
  } catch(error){
    return false;
  }
}
  

function verificarFecha(fecha){
  /* Hacemos un try catch ya que pueden meter un caracter que no puede hacerse un parseInt */
  try{
    if((parseInt(fecha.charAt(0))<=3) && (fecha.charAt(2) == '/') && (parseInt(fecha.charAt(3)))<2 && (parseInt(fecha.charAt(4))) >=0){
      var fechaHoy = new Date();
      var arrFecha = pasarAFecha(fecha);
      //console.log(arrFecha)
      var DateReserva = new Date(arrFecha[1]+"/"+(arrFecha[0])+ "/"+fechaHoy.getFullYear()); /*Generamos la fecha de la reserva en formato date.*/
      if (DateReserva.getMonth() < fechaHoy.getMonth() || (DateReserva.getMonth() === fechaHoy.getMonth() && DateReserva.getDate() < fechaHoy.getDate())) {
        /* La reserva ya habr칤a pasado de este a침o, generamos otro nuevo date que lo que va a hacer es comprobrar cuantos d칤as quedan para la misma.*/
        var dateSiguienteAno = new Date(arrFecha[1]+"/"+arrFecha[0]+ "/"+(fechaHoy.getFullYear()+1));
        //console.log(dateSiguienteAno.toString());
        var diferenciaEnMilisegundos = Math.abs(dateSiguienteAno - fechaHoy);
        var diferenciaEnDias = diferenciaEnMilisegundos / (1000 * 60 * 60 * 24);
        if(diferenciaEnDias>diasAntelacionReserva){
          //console.log('Entro aqui' + diferenciaEnDias + " " + diasAntelacionReserva);
          return false;
        }
      } else {
        /*La fecha todav칤a no ha ocurrido 칰nicamente debemos verificar que est치 en un tiempo inferior a uno determinado. */
        var diferenciaEnMilisegundos = Math.abs(DateReserva-fechaHoy);
        var diferenciaEnDias = diferenciaEnMilisegundos / (1000 * 60 * 60 * 24);
        if(diferenciaEnDias>diasAntelacionReserva)
          return false;
      }
      return true;
    }
  } catch (error){
    return false;
  }
}

function member(userID, arr, tenerEncuentaAdmins){
  /*Funci칩n que verifica si un usuario ya hecho la reserva un d칤a, los administradores estar치n libres de ello por si es para alg칰n evento. */
  if(adminsIDS.indexOf(userID) != -1 && tenerEncuentaAdmins == 0){
    return false;
  } else if(arr.indexOf(userID)!=1){
    return true;
  }
  return false;
}
async function mostrarInformacionReservas(db){
  let longitud = db.longitud;
  var texto = "```";
  for(i = 0; i < longitud; i++){
    usuario = await client.users.fetch(db.arrayUserID[i]);
    texto +=  `${usuario.displayName}: ${db.arrayHoraInicio[i]} ~ ${db.arrayHoraFin[i]} Mesa: ${db.arrayMesas[i]}\n`
  }
  texto += "```"
  return texto;
}
// Definir la funci칩n para verificar solapamiento
function seSolapan(reserva1FechaInicio,reserva1FechaFin, reserva2FechaInicio, reserva2FechaFin) {
  // Verificar solapamiento de fechas
  if (reserva1FechaFin <= reserva2FechaInicio || reserva2FechaFin <= reserva1FechaInicio) {
      return false;  // No hay solapamiento de fechas
  }

  // Verificar solapamiento de horarios
  if (reserva1FechaFin <= reserva2FechaInicio || reserva2FechaFin <= reserva1FechaInicio) {
      return false;  // No hay solapamiento de horarios
  }

  // Si no se cumple ninguna de las condiciones anteriores, hay solapamiento
  return true;
}

function verificarTiempoantelacion(fechaReserva){
  var fechaManana = new Date();
  fechaManana.setDate(fechaManana.getDate() + 1);

  var arrFecha = pasarAFecha(fechaReserva);
  var fechaReservaDate = new Date();
  fechaReservaDate.setDate(arrFecha[0]);
  fechaReservaDate.setMonth(arrFecha[1]-1);
  var diferenciaEnMilisegundos = Math.abs(fechaManana - fechaReservaDate);
  var diferenciaEnDias = diferenciaEnMilisegundos / (1000 * 60 * 60 * 24);
  return (diferenciaEnDias <=1) ? false: true;
}
function pasarAFecha(fechaReserva){
  var DiaDecena = parseInt(fechaReserva.charAt(0))*10;
  var DiaUd = parseInt(fechaReserva.charAt(1));
  var Dia =  DiaDecena + DiaUd;
  var MesDecena = parseInt(fechaReserva.charAt(3))*10;
  var MesUd = parseInt(fechaReserva.charAt(4));
  var mes = MesDecena+MesUd;
  return [Dia, mes];
}

function sacarTiempoOn(){
  var segundos = client.uptime / 1000;
  horas = 0;
  dias = 0;
  semana = 0;
  minutos = Math.floor(segundos / 60);
  segundos = Math.floor(minutos%60 );
  horas = Math.floor(minutos/60);
  minutos = Math.floor(minutos%60);
  dias = Math.floor(horas/24);
  horas = Math.floor(horas%24);
  semana = Math.floor(dias/168);
  dias = Math.floor(dias%168);
  return [semana, dias, horas, minutos, segundos];
}
function verificarCorreoInstitucional(correo){
  if(correo.includes('@alumnos.upm.es'))
    return false;
  else
    return true;
}